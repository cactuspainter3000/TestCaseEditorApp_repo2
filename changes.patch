*** Begin Patch
*** Update File: MVVM/ViewModels/MainViewModel.cs
@@
-        private async Task ImportFromPathAsync(string path, bool replace)
-        {
-            if (replace && HasUnsavedChanges && Requirements.Count > 0)
-            {
-                var res = MessageBox.Show(
-                    "You have unsaved changes. Replace the current requirements with the new import?",
-                    "Unsaved changes", MessageBoxButton.YesNo, MessageBoxImage.Warning);
-                if (res != MessageBoxResult.Yes)
-                {
-                    SetTransientStatus("Import canceled.", 2);
-                    Debug.WriteLine("[Import DEBUG] Import canceled by user (unsaved changes).");
-                    return;
-                }
-            }
-
-            try
-            {
-                var defaultFolder = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments), "TestCaseEditorApp", "Sessions");
-                Directory.CreateDirectory(defaultFolder);
-
-                var suggested = FileNameHelper.GenerateUniqueFileName(Path.GetFileNameWithoutExtension(path), ".tcex.json");
-
-                var chosen = _file_dialog_show_save_helper(suggested, defaultFolder);
-
-                if (string.IsNullOrWhiteSpace(chosen))
-                {
-                    SetTransientStatus("Import canceled (no workspace name selected).", 2);
-                    Debug.WriteLine("[Import DEBUG] Import canceled: no workspace name selected.");
-                    return;
-                }
-
-                WorkspacePath = FileNameHelper.EnsureUniquePath(Path.GetDirectoryName(chosen)!, Path.GetFileName(chosen));
-
-                SetTransientStatus($"Importing {Path.GetFileName(path)}â€¦", 0);
-                Debug.WriteLine($"[Import DEBUG] StatusMessage after starting import: '{StatusMessage}'");
-
-                var sw = Stopwatch.StartNew();
-
-                // --- diagnostic logging (safe whether the import callable is a method or a delegate) ---
-                System.Diagnostics.Debug.WriteLine($"[Import DEBUG] requirementService instance: {_requirementService?.GetType().FullName ?? "<null>"}");
-
-                // Try to detect a delegate field first (if you actually have a delegate instance)
-                try
-                {
-                    var field = this.GetType().GetField("_requirement_service_call_for_import",
-                                                       System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Public);
-                    if (field != null)
-                    {
-                        var val = field.GetValue(this);
-                        if (val is Delegate d)
-                        {
-                            var mi = d.Method;
-                            System.Diagnostics.Debug.WriteLine($"[Import DEBUG] import delegate field -> {mi.DeclaringType?.FullName}.{mi.Name} (IsStatic={mi.IsStatic})");
-                        }
-                        else
-                        {
-                            System.Diagnostics.Debug.WriteLine("[Import DEBUG] _requirement_service_call_for_import field exists but is not a Delegate instance.");
-                        }
-                    }
-                    else
-                    {
-                        // Fallback: try to find a method with that name on this type (method group)
-                        var mi = this.GetType().GetMethod("_requirement_service_call_for_import",
-                                    System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Public);
-                        if (mi != null)
-                        {
-                            System.Diagnostics.Debug.WriteLine($"[Import DEBUG] import method found -> {mi.DeclaringType?.FullName}.{mi.Name} (IsStatic={mi.IsStatic})");
-                        }
-                        else
-                        {
-                            System.Diagnostics.Debug.WriteLine("[Import DEBUG] No field or method named _requirement_service_call_for_import found on this MainViewModel instance.");
-                        }
-                    }
-                }
-                catch (Exception ex)
-                {
-                    System.Diagnostics.Debug.WriteLine("[Import DEBUG] detection error: " + ex);
-                }
-
-                // Parse on background thread (your existing service call)
-                //var reqs = await Task.Run(() => _requirement_service_call_for_import(path));
-
-                var reqs = await Task.Run(() => _requirementService?.ImportRequirementsFromJamaAllDataDocx(path) ?? new List<Requirement>()); System.Diagnostics.Debug.WriteLine($"[Import DEBUG] direct service call returned {reqs?.Count ?? 0} requirements");
-
-                sw.Stop();
-
-                // --- DIAGNOSTIC SNAPSHOT (written even when parsing returns zero) ---
-                try
-                {
-                    var tmp = Path.Combine(Path.GetTempPath(), $"tce_import_debug_{DateTime.UtcNow:yyyyMMdd_HHmmss}.txt");
-                    using var swf = new StreamWriter(tmp, false, new UTF8Encoding(encoderShouldEmitUTF8Identifier: true));
-                    swf.WriteLine("Import debug snapshot");
-                    swf.WriteLine("Source DOCX: " + path);
-                    swf.WriteLine("Parsed requirement count: " + (reqs?.Count ?? 0));
-                    swf.WriteLine("");
-
-                    if (reqs != null && reqs.Count > 0)
-                    {
-                        swf.WriteLine("First parsed requirement entries (up to 10):");
-                        for (int i = 0; i < Math.Min(10, reqs.Count); i++)
-                        {
-                            var r = reqs[i];
-                            swf.WriteLine($"{i + 1}: Item='{r?.Item}' Name='{r?.Name}' DescLength={(r?.Description?.Length ?? 0)}");
-                        }
-                    }
-                    else
-                    {
-                        swf.WriteLine("Parser returned zero requirements. Dumping first non-empty DOCX paragraphs for inspection:");
-                        try
-                        {
-                            using var wordDoc = DocumentFormat.OpenXml.Packaging.WordprocessingDocument.Open(path, false);
-                            var paragraphs = wordDoc.MainDocumentPart?.Document?.Body?.Elements<DocumentFormat.OpenXml.Wordprocessing.Paragraph>()
-                                                .Select(p => (p.InnerText ?? "").Trim()).Where(s => s.Length > 0).ToList() ?? new List<string>();
-
-                            for (int i = 0; i < Math.Min(120, paragraphs.Count); i++)
-                                swf.WriteLine($"[{i + 1}] {paragraphs[i]}");
-                        }
-                        catch (Exception ex)
-                        {
-                            swf.WriteLine("Failed to read DOCX paragraphs for debug: " + ex.Message);
-                        }
-                    }
-
-                    swf.Flush();
-                    Debug.WriteLine("[Import DEBUG] Wrote parse debug to: " + tmp);
-                }
-                catch (Exception ex)
-                {
-                    Debug.WriteLine("[Import DEBUG] Diagnostic snapshot failed: " + ex);
-                }
-                // --- end diagnostic snapshot ---
-
-                // Build workspace model
-                CurrentWorkspace = new Workspace
-                {
-                    SourceDocPath = path,
-                    Requirements = reqs.ToList()
-                };
-
-                // Seed defaults from project template (best-effort)
-                object? template = null;
-                try { template = DefaultsHelper.LoadProjectDefaultsTemplate(); } catch (Exception ex) { Debug.WriteLine("[Import] DefaultsHelper failed: " + ex); }
-
-                if (template is DefaultsBlock dbTemplate)
-                {
-                    CurrentWorkspace.Defaults = dbTemplate;
-                }
-                else if (template is DefaultsCatalogDto catalogDto)
-                {
-                    CurrentWorkspace.Defaults = new DefaultsBlock
-                    {
-                        Version = 1,
-                        Catalog = catalogDto,
-                        State = new DefaultsState { SelectedPreset = "Bench (default)" }
-                    };
-                }
-                else if (template != null)
-                {
-                    try
-                    {
-                        dynamic dyn = template;
-                        var catalog = new DefaultsCatalogDto();
-                        try { catalog.Items = dyn.Items; } catch { }
-                        try { catalog.Presets = dyn.Presets; } catch { }
-
-                        CurrentWorkspace.Defaults = new DefaultsBlock
-                        {
-                            Version = 1,
-                            Catalog = catalog,
-                            State = new DefaultsState { SelectedPreset = "Bench (default)" }
-                        };
-                    }
-                    catch
-                    {
-                        CurrentWorkspace.Defaults = new DefaultsBlock { Version = 1, Catalog = null, State = new DefaultsState { SelectedPreset = "Bench (default)" } };
-                    }
-                }
-                else
-                {
-                    CurrentWorkspace.Defaults = new DefaultsBlock { Version = 1, Catalog = null, State = new DefaultsState { SelectedPreset = "Bench (default)" } };
-                }
-
-                // Update UI-bound collection (replace the collection instance so bindings refresh)
-                Requirements = new ObservableCollection<Requirement>(reqs);
-                CurrentWorkspace.Requirements = Requirements.ToList();
-
-                try { WorkspaceService.Save(WorkspacePath!, CurrentWorkspace); } catch (Exception ex) { Debug.WriteLine("[Import] WorkspaceService.Save failed: " + ex); }
-
-                HasUnsavedChanges = false;
-
-                try { _testCaseGenerator?.LoadDefaultsFromWorking(CurrentWorkspace.Defaults ?? new DefaultsBlock()); } catch (Exception ex) { Debug.WriteLine("[Import] TestCaseGenerator.LoadDefaults failed: " + ex); }
-
-                CurrentRequirement = Requirements.FirstOrDefault();
-                RefreshSupportingInfo();
-
-                var db = CurrentWorkspace.Defaults ?? new DefaultsBlock();
-                try
-                {
-                    if (db != null && db.Catalog?.Items != null)
-                    {
-                        foreach (var it in db.Catalog.Items)
-                            Debug.WriteLine($"[MainViewModel] DefaultItem: Key='{it?.Key}', Name='{it?.Name}'");
-                    }
-                }
-                catch (Exception ex) { Debug.WriteLine("[MainViewModel] Exception while logging defaults: " + ex); }
-
-                try { _testCaseGenerator?.LoadDefaultsFromWorking(db); } catch (Exception ex) { Debug.WriteLine("[Import] TestCaseGenerator.LoadDefaultsFromWorking (2) failed: " + ex); }
-
-                WordFilePath = null;
-                CurrentSourcePath = null;
-
-                ComputeDraftedCount();
-                RaiseCounterChanges();
-
-                if (Requirements.Count == 0)
-                {
-                    // Friendly message + open folder so the user can inspect the saved files and diagnostic snapshot
-                    SetTransientStatus($"Import completed: 0 requirements â€” see logs in LocalAppData\\TestCaseEditorApp\\imports", 8);
-                    try
-                    {
-                        // Give the user the folder with the workspace and the debug file (if the debug file exists)
-                        var folder = Path.GetDirectoryName(WorkspacePath) ?? Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);
-                        Process.Start(new ProcessStartInfo("explorer.exe", $"\"{folder}\"") { UseShellExecute = true });
-                    }
-                    catch { /* best-effort */ }
-                }
-                else
-                {
-                    _requirementsNavigator?.NotifyCurrentRequirementChanged();
-                    Debug.WriteLine($"[Import] CurrentRequirement set to: {CurrentRequirement?.Item} â€¢ {CurrentRequirement?.Name} (Total: {Requirements.Count})");
-                }
-
-                SetTransientStatus($"ðŸ’¾ Workspace created: {Path.GetFileName(WorkspacePath)} â€¢ {Requirements.Count} requirement(s) â€¢ {sw.ElapsedMilliseconds} ms", 6);
-                Debug.WriteLine($"[Import DEBUG] final StatusMessage='{StatusMessage}'");
-            }
-            catch (NotSupportedException ex)
-            {
-                Status = ex.Message;
-                Debug.WriteLine("[Import ERROR] NotSupportedException: " + ex.Message);
-            }
-            catch (IOException)
-            {
-                Status = "Close the Word file and try again.";
-                Debug.WriteLine("[Import ERROR] IOException during import.");
-            }
-            catch (Exception ex)
-            {
-                SaveSessionAuto();
-                Status = "Import failed: " + ex.Message;
-                Debug.WriteLine("[Import ERROR] Exception during import: " + ex.ToString());
-            }
-        }
+        private async Task ImportFromPathAsync(string path, bool replace)
+        {
+            if (replace && HasUnsavedChanges && Requirements.Count > 0)
+            {
+                var res = MessageBox.Show(
+                    "You have unsaved changes. Replace the current requirements with the new import?",
+                    "Unsaved changes", MessageBoxButton.YesNo, MessageBoxImage.Warning);
+                if (res != MessageBoxResult.Yes)
+                {
+                    SetTransientStatus("Import canceled.", 2);
+                    Debug.WriteLine("[Import] Import canceled by user (unsaved changes).");
+                    return;
+                }
+            }
+
+            try
+            {
+                var defaultFolder = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments), "TestCaseEditorApp", "Sessions");
+                Directory.CreateDirectory(defaultFolder);
+
+                var suggested = FileNameHelper.GenerateUniqueFileName(Path.GetFileNameWithoutExtension(path), ".tcex.json");
+
+                var chosen = _file_dialog_show_save_helper(suggested, defaultFolder);
+
+                if (string.IsNullOrWhiteSpace(chosen))
+                {
+                    SetTransientStatus("Import canceled (no workspace name selected).", 2);
+                    Debug.WriteLine("[Import] Import canceled: no workspace name selected.");
+                    return;
+                }
+
+                WorkspacePath = FileNameHelper.EnsureUniquePath(Path.GetDirectoryName(chosen)!, Path.GetFileName(chosen));
+
+                SetTransientStatus($"Importing {Path.GetFileName(path)}â€¦", 0);
+                Debug.WriteLine($"[Import] Starting import of '{path}'");
+
+                var sw = Stopwatch.StartNew();
+
+                // Diagnostic: which requirement service is wired (should be the DI-provided implementation)
+                Debug.WriteLine($"[Import] requirementService = {_requirementService?.GetType().FullName ?? "<null>"}");
+
+                // Run parser on background thread
+                var reqs = await Task.Run(() => _requirementService?.ImportRequirementsFromJamaAllDataDocx(path) ?? new List<Requirement>());
+                Debug.WriteLine($"[Import] Parser returned {reqs?.Count ?? 0} requirement(s)");
+
+                sw.Stop();
+
+                // If parser returned zero, write a diagnostic DOCX snapshot for later inspection
+                if (reqs == null || reqs.Count == 0)
+                {
+                    try
+                    {
+                        var tmp = Path.Combine(Path.GetTempPath(), $"tce_import_debug_{DateTime.UtcNow:yyyyMMdd_HHmmss}.txt");
+                        using var swf = new StreamWriter(tmp, false, new UTF8Encoding(encoderShouldEmitUTF8Identifier: true));
+                        swf.WriteLine("Import debug snapshot");
+                        swf.WriteLine("Source DOCX: " + path);
+                        swf.WriteLine("Parsed requirement count: 0");
+                        swf.WriteLine("");
+
+                        swf.WriteLine("Dumping first non-empty DOCX paragraphs for inspection (up to 120):");
+                        try
+                        {
+                            using var wordDoc = DocumentFormat.OpenXml.Packaging.WordprocessingDocument.Open(path, false);
+                            var paragraphs = wordDoc.MainDocumentPart?.Document?.Body?.Elements<DocumentFormat.OpenXml.Wordprocessing.Paragraph>()
+                                                .Select(p => (p.InnerText ?? "").Trim()).Where(s => s.Length > 0).ToList() ?? new List<string>();
+
+                            for (int i = 0; i < Math.Min(120, paragraphs.Count); i++)
+                                swf.WriteLine($"[{i + 1}] {paragraphs[i]}");
+                        }
+                        catch (Exception ex)
+                        {
+                            swf.WriteLine("Failed to read DOCX paragraphs for debug: " + ex.Message);
+                        }
+
+                        swf.Flush();
+                        Debug.WriteLine("[Import] Wrote parse debug to: " + tmp);
+                    }
+                    catch (Exception ex)
+                    {
+                        Debug.WriteLine("[Import] Diagnostic snapshot failed: " + ex);
+                    }
+                }
+
+                // Build workspace model
+                CurrentWorkspace = new Workspace
+                {
+                    SourceDocPath = path,
+                    Requirements = reqs.ToList()
+                };
+
+                // Seed defaults from project template (best-effort)
+                object? template = null;
+                try { template = DefaultsHelper.LoadProjectDefaultsTemplate(); } catch (Exception ex) { Debug.WriteLine("[Import] DefaultsHelper failed: " + ex); }
+
+                if (template is DefaultsBlock dbTemplate)
+                {
+                    CurrentWorkspace.Defaults = dbTemplate;
+                }
+                else if (template is DefaultsCatalogDto catalogDto)
+                {
+                    CurrentWorkspace.Defaults = new DefaultsBlock
+                    {
+                        Version = 1,
+                        Catalog = catalogDto,
+                        State = new DefaultsState { SelectedPreset = "Bench (default)" }
+                    };
+                }
+                else if (template != null)
+                {
+                    try
+                    {
+                        dynamic dyn = template;
+                        var catalog = new DefaultsCatalogDto();
+                        try { catalog.Items = dyn.Items; } catch { }
+                        try { catalog.Presets = dyn.Presets; } catch { }
+
+                        CurrentWorkspace.Defaults = new DefaultsBlock
+                        {
+                            Version = 1,
+                            Catalog = catalog,
+                            State = new DefaultsState { SelectedPreset = "Bench (default)" }
+                        };
+                    }
+                    catch
+                    {
+                        CurrentWorkspace.Defaults = new DefaultsBlock { Version = 1, Catalog = null, State = new DefaultsState { SelectedPreset = "Bench (default)" } };
+                    }
+                }
+                else
+                {
+                    CurrentWorkspace.Defaults = new DefaultsBlock { Version = 1, Catalog = null, State = new DefaultsState { SelectedPreset = "Bench (default)" } };
+                }
+
+                // Update UI-bound collection: preserve existing ObservableCollection instance so navigators stay wired.
+                reqs = reqs ?? new List<Requirement>();
+
+                // --- Bulk update: suspend collection-change handler to avoid per-item side-effects/noise ---
+                try
+                {
+                    // detach handler that reacts to Requirements changes to avoid repeated side-effects
+                    Requirements.CollectionChanged -= RequirementsOnCollectionChanged;
+
+                    if (Application.Current?.Dispatcher?.CheckAccess() == true)
+                    {
+                        Requirements.Clear();
+                        foreach (var r in reqs) Requirements.Add(r);
+                    }
+                    else
+                    {
+                        Application.Current?.Dispatcher?.Invoke(() =>
+                        {
+                            Requirements.Clear();
+                            foreach (var r in reqs) Requirements.Add(r);
+                        });
+                    }
+                }
+                finally
+                {
+                    // reattach handler after bulk update
+                    Requirements.CollectionChanged += RequirementsOnCollectionChanged;
+                }
+
+                // Keep CurrentWorkspace in sync
+                CurrentWorkspace.Requirements = Requirements.ToList();
+
+                try
+                {
+                    if (!string.IsNullOrWhiteSpace(WorkspacePath))
+                        WorkspaceService.Save(WorkspacePath!, CurrentWorkspace);
+                }
+                catch (Exception ex)
+                {
+                    Debug.WriteLine("[Import] WorkspaceService.Save failed: " + ex);
+                }
+
+                HasUnsavedChanges = false;
+
+                try { _testCaseGenerator?.LoadDefaultsFromWorking(CurrentWorkspace.Defaults ?? new DefaultsBlock()); } catch (Exception ex) { Debug.WriteLine("[Import] TestCaseGenerator.LoadDefaults failed: " + ex); }
+
+                CurrentRequirement = Requirements.FirstOrDefault();
+                RefreshSupportingInfo();
+
+                var db = CurrentWorkspace.Defaults ?? new DefaultsBlock();
+                try
+                {
+                    if (db != null && db.Catalog?.Items != null)
+                    {
+                        foreach (var it in db.Catalog.Items)
+                            Debug.WriteLine($"[MainViewModel] DefaultItem: Key='{it?.Key}', Name='{it?.Name}'");
+                    }
+                }
+                catch (Exception ex) { Debug.WriteLine("[MainViewModel] Exception while logging defaults: " + ex); }
+
+                try { _testCaseGenerator?.LoadDefaultsFromWorking(db); } catch (Exception ex) { Debug.WriteLine("[Import] TestCaseGenerator.LoadDefaultsFromWorking (2) failed: " + ex); }
+
+                WordFilePath = null;
+                CurrentSourcePath = null;
+
+                ComputeDraftedCount();
+                RaiseCounterChanges();
+
+                // Single notification to navigator after full update
+                _requirementsNavigator?.NotifyCurrentRequirementChanged();
+
+                // Concise navigator diagnostic (single line) using safe reflection to check ReferenceEquals
+                try
+                {
+                    var navType = _requirementsNavigator?.GetType().FullName ?? "<null>";
+                    bool navigatorRefsRequirements = false;
+                    try
+                    {
+                        object? navColObj = null;
+                        var nav = _requirementsNavigator;
+                        if (nav != null)
+                        {
+                            var p = nav.GetType().GetProperty("Requirements", System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.NonPublic);
+                            if (p != null) navColObj = p.GetValue(nav);
+                            else
+                            {
+                                var f = nav.GetType().GetField("_requirements", System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Public)
+                                        ?? nav.GetType().GetField("requirements", System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Public);
+                                if (f != null) navColObj = f.GetValue(nav);
+                            }
+                        }
+                        navigatorRefsRequirements = ReferenceEquals(navColObj, Requirements);
+                    }
+                    catch (Exception) { /* best-effort diagnostics only */ }
+                    Debug.WriteLine($"[NAV DIAG] Requirements.Count={Requirements?.Count ?? -1}; NavigatorType={navType}; NavigatorRefsRequirements={navigatorRefsRequirements}");
+                }
+                catch (Exception) { /* don't let diagnostics break import */ }
+
+                if (Requirements.Count == 0)
+                {
+                    SetTransientStatus($"Import completed: 0 requirements â€” see logs in LocalAppData\\TestCaseEditorApp\\imports", 8);
+                    try
+                    {
+                        var folder = Path.GetDirectoryName(WorkspacePath) ?? Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);
+                        Process.Start(new ProcessStartInfo("explorer.exe", $"\"{folder}\"") { UseShellExecute = true });
+                    }
+                    catch { /* best-effort */ }
+                }
+                else
+                {
+                    Debug.WriteLine($"[Import] CurrentRequirement set to: {CurrentRequirement?.Item} â€¢ {CurrentRequirement?.Name} (Total: {Requirements.Count})");
+                }
+
+                SetTransientStatus($"ðŸ’¾ Workspace created: {Path.GetFileName(WorkspacePath)} â€¢ {Requirements.Count} requirement(s) â€¢ {sw.ElapsedMilliseconds} ms", 6);
+                Debug.WriteLine($"[Import] final status: '{StatusMessage}'");
+            }
+            catch (NotSupportedException ex)
+            {
+                Status = ex.Message;
+                Debug.WriteLine("[Import ERROR] NotSupportedException: " + ex.Message);
+            }
+            catch (IOException)
+            {
+                Status = "Close the Word file and try again.";
+                Debug.WriteLine("[Import ERROR] IOException during import.");
+            }
+            catch (Exception ex)
+            {
+                SaveSessionAuto();
+                Status = "Import failed: " + ex.Message;
+                Debug.WriteLine("[Import ERROR] Exception during import: " + ex.ToString());
+            }
+        }
*** End Patch
*** Begin Patch
*** Update File: MVVM/ViewModels/RequirementsIndexViewModel.cs
@@
     public class RequirementsIndexViewModel : ObservableObject
     {
-        private readonly ObservableCollection<Requirement> _requirements;
-        private readonly Func<Requirement?> _getCurrentRequirement;
-        private readonly Action<Requirement?> _setCurrentRequirement;
-        private readonly Action? _commitPendingEdits;
+        private readonly ObservableCollection<Requirement> _requirements;
+        private readonly Func<Requirement?> _getCurrentRequirement;
+        private readonly Action<Requirement?> _setCurrentRequirement;
+        private readonly Action? _commitPendingEdits;
 
         public RequirementsIndexViewModel(
             ObservableCollection<Requirement> requirements,
             Func<Requirement?> getCurrentRequirement,
             Action<Requirement?> setCurrentRequirement,
             Action? commitPendingEdits = null)
         {
             _requirements = requirements ?? throw new ArgumentNullException(nameof(requirements));
             _getCurrentRequirement = getCurrentRequirement ?? throw new ArgumentNullException(nameof(getCurrentRequirement));
             _setCurrentRequirement = setCurrentRequirement ?? throw new ArgumentNullException(nameof(setCurrentRequirement));
             _commitPendingEdits = commitPendingEdits;
 
-            // Commands
-            PrevCommand = new RelayCommand(ExecutePrev, CanExecutePrev);
-            NextCommand = new RelayCommand(ExecuteNext, CanExecuteNext);
-
-            // Keep collection changes observed so command availability updates
-            _requirements.CollectionChanged += (_, __) => NotifyCommands();
+            // Commands - expose names the view expects (PreviousRequirementCommand / NextRequirementCommand)
+            PreviousRequirementCommand = new RelayCommand(ExecutePrev, CanExecutePrev);
+            NextRequirementCommand = new RelayCommand(ExecuteNext, CanExecuteNext);
+
+            // Keep collection changes observed so command availability and position display update
+            _requirements.CollectionChanged += (_, __) =>
+            {
+                NotifyCommands();
+                OnPropertyChanged(nameof(RequirementPositionDisplay));
+            };
         }
 
-        // Exposed ICommand for UI
-        public ICommand PrevCommand { get; }
-        public ICommand NextCommand { get; }
+        // Exposed collection reference for the view to bind ItemsSource to.
+        public ObservableCollection<Requirement> Requirements => _requirements;
+
+        // Exposed ICommand properties matching XAML bindings
+        public IRelayCommand PreviousRequirementCommand { get; }
+        public IRelayCommand NextRequirementCommand { get; }
 
         // SelectedRequirement is mirror of host's current requirement for binding convenience.
         // When set locally, we call back into the host via _setCurrentRequirement.
         private Requirement? _selectedRequirement;
         public Requirement? SelectedRequirement
         {
-            get => _selectedRequirement ?? _getCurrentRequirement();
-            set
-            {
-                if (Equals(_selectedRequirement, value)) return;
-                _selectedRequirement = value;
-                OnPropertyChanged(nameof(SelectedRequirement));
-                // Commit pending edits in host before changing selection
-                _commitPendingEdits?.Invoke();
-                _setCurrentRequirement?.Invoke(value);
-                NotifyCommands();
-            }
+            get => _selectedRequirement ?? _getCurrentRequirement();
+            set
+            {
+                if (Equals(_selectedRequirement, value)) return;
+                _selectedRequirement = value;
+                OnPropertyChanged(nameof(SelectedRequirement));
+
+                // Commit pending edits in host before changing selection
+                _commitPendingEdits?.Invoke();
+                _setCurrentRequirement?.Invoke(value);
+
+                Debug.WriteLine($"[NAV] SelectedRequirement set -> {value?.Item ?? "<null>"}");
+                NotifyCommands();
+                OnPropertyChanged(nameof(RequirementPositionDisplay));
+            }
         }
 
+        // Readable position display for the UI (e.g. "3 / 31")
+        public string RequirementPositionDisplay
+        {
+            get
+            {
+                var cur = _getCurrentRequirement();
+                if (cur == null || _requirements.Count == 0) return "â€”";
+                var idx = _requirements.IndexOf(cur);
+                if (idx < 0) return "â€”";
+                return $"{idx + 1} / {_requirements.Count}";
+            }
+        }
+
         // Called by the host (MainViewModel) when it sets its CurrentRequirement so the navigator can sync.
         public void NotifyCurrentRequirementChanged()
         {
             // Clear any cached selection so getter pulls from host delegate,
             // then raise property changed so bindings update.
             _selectedRequirement = null;
-            OnPropertyChanged(nameof(SelectedRequirement));
-            NotifyCommands();
+            OnPropertyChanged(nameof(SelectedRequirement));
+            OnPropertyChanged(nameof(RequirementPositionDisplay));
+            NotifyCommands();
+
+            Debug.WriteLine($"[NAV] NotifyCurrentRequirementChanged invoked. Current={_getCurrentRequirement()?.Item ?? "<null>"}, Count={_requirements.Count}");
         }
 
         private void ExecutePrev()
         {
             var cur = _getCurrentRequirement();
             if (cur == null)
             {
                 if (_requirements.Count > 0)
                 {
                     _commitPendingEdits?.Invoke();
                     _setCurrentRequirement(_requirements[0]);
                     return;
                 }
                 return;
             }
 
             var idx = _requirements.IndexOf(cur);
             if (idx > 0)
             {
                 _commitPendingEdits?.Invoke();
                 _setCurrentRequirement(_requirements[idx - 1]);
             }
         }
 
         private bool CanExecutePrev() => _getCurrentRequirement() != null && _requirements.IndexOf(_getCurrentRequirement()!) > 0;
 
         private void ExecuteNext()
         {
             var cur = _getCurrentRequirement();
             if (cur == null)
             {
                 if (_requirements.Count > 0)
                 {
                     _commitPendingEdits?.Invoke();
                     _setCurrentRequirement(_requirements[0]);
                     return;
                 }
                 return;
             }
 
             var idx = _requirements.IndexOf(cur);
             if (idx >= 0 && idx < _requirements.Count - 1)
             {
                 _commitPendingEdits?.Invoke();
                 _setCurrentRequirement(_requirements[idx + 1]);
             }
         }
 
-        private bool CanExecuteNext() => _getCurrentRequirement() != null && _requirements.IndexOf(_getCurrentRequirement()!) < _requirements.Count - 1;
-
-        private void NotifyCommands()
-        {
-            (PrevCommand as IRelayCommand)?.NotifyCanExecuteChanged();
-            (NextCommand as IRelayCommand)?.NotifyCanExecuteChanged();
-        }
+        private bool CanExecuteNext() => _getCurrentRequirement() != null && _requirements.IndexOf(_getCurrentRequirement()!) < _requirements.Count - 1;
+
+        private void NotifyCommands()
+        {
+            PreviousRequirementCommand?.NotifyCanExecuteChanged();
+            NextRequirementCommand?.NotifyCanExecuteChanged();
+        }
     }
 }
*** End Patch
*** Begin Patch
*** Update File: MVVM/Views/MainWindow.xaml
@@
-            <views:RequirementsNavigationControl Grid.Column="2" Grid.Row="6" DataContext="{Binding Navigation.RequirementsNav}" />
+            <views:RequirementsNavigationControl
+                x:Name="RequirementsNavigationControl"
+                Grid.Column="2"
+                Grid.Row="6"
+                DataContext="{Binding RequirementsNavigator}" />
*** End Patch