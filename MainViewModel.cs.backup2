using System;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Diagnostics;
using System.Windows;
using System.Windows.Input;
using System.Windows.Threading;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Win32;
using TestCaseEditorApp.MVVM.Models;
using TestCaseEditorApp.MVVM.Domains.WorkspaceManagement.ViewModels;
using TestCaseEditorApp.MVVM.Domains.WorkspaceManagement.Mediators;
using TestCaseEditorApp.MVVM.Domains.WorkspaceManagement.Events;
using TestCaseEditorApp.MVVM.Domains.ChatGptExportAnalysis.ViewModels;
using TestCaseEditorApp.MVVM.Domains.RequirementAnalysisWorkflow.ViewModels;
using TestCaseEditorApp.Helpers;
using TestCaseEditorApp.Services;
using TestCaseEditorApp.MVVM.Domains.TestCaseGeneration.Services;
using TestCaseEditorApp.MVVM.Domains.TestCaseGeneration.Mediators;
using TestCaseEditorApp.MVVM.Domains.TestCaseGeneration.ViewModels;
using TestCaseEditorApp.MVVM.Domains.TestFlow.Mediators;
using Microsoft.Extensions.Logging;
using System.Reflection;
using System.Text;
using System.Collections.Specialized;
using TestCaseEditorApp.Services.Prompts;
using TestCaseEditorApp.MVVM.Utils;

namespace TestCaseEditorApp.MVVM.ViewModels
{
    /// <summary>
    /// MainViewModel serves as a simple container that sets up the 4 workspace areas.
    /// Following architectural guidelines: NO coordination logic, just workspace setup.
    /// All domain logic is delegated to appropriate domain mediators and ViewModels.
    /// </summary>
    public partial class MainViewModel : ObservableObject, IDisposable
    {
        // === SIMPLE CONTAINER FIELDS ===
        // MainViewModel should only manage 4 workspace areas, no coordination logic
        private readonly IViewAreaCoordinator _viewAreaCoordinator;
        private readonly IViewModelFactory _viewModelFactory;
        private readonly ILogger<MainViewModel>? _logger;
        
        // === LEGACY COMPATIBILITY PROPERTIES ===
        // These provide backward compatibility during migration
        
        // Navigation mediator access
        public INavigationMediator NavigationMediator => _viewAreaCoordinator.NavigationMediator;
        
        // Main workspace areas - delegate to ViewAreaCoordinator
        public object? MainWorkspace => _viewAreaCoordinator.WorkspaceContent.CurrentContent;
        public object? HeaderWorkspace => _viewAreaCoordinator.HeaderArea.ActiveHeader;
        public object? NavigationWorkspace => _viewAreaCoordinator.NavigationMediator.CurrentContent;
        public object? SideMenuWorkspace => _viewAreaCoordinator.SideMenu;

        private ImportMethodSelectionViewModel? _importMethodViewModel;

        // TODO: EXTRACT TO UIModalManagementViewModel - property delegation
        public string ModalTitle => _uiModalManagement?.ModalTitle ?? "Modal Dialog";

        public ICommand? CloseModalCommand { get; private set; }

        private Requirement? _currentRequirement;
        public Requirement? CurrentRequirement
        {
            get => _currentRequirement;
            set
            {
                // Save BEFORE changing requirement so we can access the OLD requirement's data
                if (_currentRequirement != value && _isDirty)
                {
                    SavePillSelectionsBeforeNavigation();
                }

                if (SetProperty(ref _currentRequirement, value))
                {
                    // Delegate the complex logic to NavigationHeaderManagementViewModel
                    _navigationHeaderManagement?.OnCurrentRequirementChanged(value, _currentRequirement, CurrentStepViewModel, _workspaceHeaderViewModel, _requirementsNavigator, IsLlmBusy, ExportForChatGptCommand as RelayCommand);
                    
                    OnPropertyChanged(nameof(RequirementPositionDisplay));
                }
            }
        }

        // --- Other persisted/view state ---
        private string? _workspacePath;
        public string? WorkspacePath
        {
            get => _workspacePath;
            set => SetProperty(ref _workspacePath, value);
        }

        private string? _currentAnythingLLMWorkspaceSlug;
        public string? CurrentAnythingLLMWorkspaceSlug
        {
            get => _currentAnythingLLMWorkspaceSlug;
            set => SetProperty(ref _currentAnythingLLMWorkspaceSlug, value);
        }

        // Static initialization guard to prevent multiple instances from initializing AnythingLLM
        internal static bool _anythingLLMInitializing = false;
        private static readonly object _initializationLock = new object();

        // AnythingLLM Status Properties - Track LlmConnectionManager with proper notifications
        [ObservableProperty]
        private bool isAnythingLLMAvailable;
        
        [ObservableProperty]
        private bool isAnythingLLMStarting;
        
        [ObservableProperty]
        private string anythingLLMStatusMessage = "Initializing AnythingLLM...";

        private bool _requirementsCollectionHooked;
        private bool _hasUnsavedChanges;
        public bool HasUnsavedChanges
        {
            get => _hasUnsavedChanges;
            set => SetProperty(ref _hasUnsavedChanges, value);
        }

        private string? _statusMessage;
        public string? StatusMessage
        {
            get => _statusMessage;
            set => SetProperty(ref _statusMessage, value);
        }

        private string? _wordFilePath;
        public string? WordFilePath
        {
            get => _wordFilePath;
            set => SetProperty(ref _wordFilePath, value);
        }

        private string? _currentSourcePath;
        public string? CurrentSourcePath
        {
            get => _currentSourcePath;
            set => SetProperty(ref _currentSourcePath, value);
        }

        // User setting: auto-run requirement analysis after importing a workspace/source
        private bool _autoAnalyzeOnImport = true;
        public bool AutoAnalyzeOnImport
        {
            get => _autoAnalyzeOnImport;
            set
            {
                if (SetProperty(ref _autoAnalyzeOnImport, value))
                {
                    try { _persistence?.Save("AutoAnalyzeOnImport", value); } catch { }
                }
            }
        }

        private bool _autoExportForChatGpt = false;
        public bool AutoExportForChatGpt
        {
            get => _autoExportForChatGpt;
            set
            {
                if (SetProperty(ref _autoExportForChatGpt, value))
                {
                    try { _persistence?.Save("AutoExportForChatGpt", value); } catch { }
                }
            }
        }

        private string? _lastChatGptExportFilePath;
        public string? LastChatGptExportFilePath
        {
            get => _lastChatGptExportFilePath;
            set
            {
                if (SetProperty(ref _lastChatGptExportFilePath, value))
                {
                    ((RelayCommand?)OpenChatGptExportCommand)?.NotifyCanExecuteChanged();
                }
            }
        }

        // Command to toggle auto-analysis (useful for binding to a settings checkbox/menu)
        public ICommand? ToggleAutoAnalyzeCommand { get; }

        private ObservableCollection<LooseTableViewModel> _looseTables = new ObservableCollection<LooseTableViewModel>();
        public ObservableCollection<LooseTableViewModel> LooseTables => _looseTables;

        private ObservableCollection<string> _looseParagraphs = new ObservableCollection<string>();
        public ObservableCollection<string> LooseParagraphs => _looseParagraphs;

        // Steps UI
        public ObservableCollection<StepDescriptor> TestCaseGeneratorSteps { get; } = new ObservableCollection<StepDescriptor>();

        // Test Flow steps (from side menu)
        public ObservableCollection<StepDescriptor> TestFlowSteps { get; } = new ObservableCollection<StepDescriptor>();

        // Display name for window title
        private string _displayName = "Test Case Editor";
        public string DisplayName
        {
            get => _displayName;
            set => SetProperty(ref _displayName, value);
        }

        // SAP status properties (from side menu)
        private string _sapStatus = string.Empty;
        public string SapStatus
        {
            get => _sapStatus;
            set
            {
                if (SetProperty(ref _sapStatus, value))
                {
                    OnPropertyChanged(nameof(SapForegroundStatus));
                }
            }
        }

        public System.Windows.Media.Brush SapForegroundStatus
        {
            get
            {
                if (string.IsNullOrWhiteSpace(SapStatus)) return System.Windows.Media.Brushes.Transparent;
                return string.Equals(SapStatus, "OK", StringComparison.OrdinalIgnoreCase) || 
                       string.Equals(SapStatus, "Connected", StringComparison.OrdinalIgnoreCase)
                    ? System.Windows.Media.Brushes.LightGreen
                    : System.Windows.Media.Brushes.Orange;
            }
        }

        private RequirementsIndexViewModel? _requirementsNavigator;

        public RequirementsIndexViewModel RequirementsNavigator => _requirementsNavigator!;

        // Timer for transient status messages
        private DispatcherTimer? _statusTimer;

        // Auto-save service for periodic workspace saves
        private TestCaseEditorApp.Services.AutoSaveService? _autoSaveService;
        private const int AutoSaveIntervalMinutes = 5;

        // Recent files service for tracking recently opened workspaces
        private RecentFilesService? _recentFilesService;
        
        // Analysis service removed - was never used

        // Delegate batch analysis state to domain ViewModel
        // TODO: EXTRACT TO RequirementAnalysisViewModel - property delegation
        public bool IsBatchAnalyzing => _requirementAnalysisManagement?.IsBatchAnalyzing ?? false;

        // Minimal test case generator placeholder used by TestCaseGenerator_VM instances
        private TestCaseGenerator_CoreVM? _testCaseGenerator = new TestCaseGenerator_CoreVM();

        // header adapter for test-case-creator UI
        private INotifyPropertyChanged? _linkedTestCaseGeneratorInpc;



        // Commands exposed directly (so bindings can reference them without source-generation)
        public IRelayCommand? NextRequirementCommand { get; }
        public IRelayCommand? PreviousRequirementCommand { get; }
        public IRelayCommand? NextWithoutTestCaseCommand { get; }
        public IAsyncRelayCommand? ImportWordCommand { get; private set; }
        public IAsyncRelayCommand? QuickImportCommand { get; private set; }
        public ICommand? LoadWorkspaceCommand { get; private set; }
        public ICommand? SaveWorkspaceCommand { get; private set; }
        public ICommand? ReloadCommand { get; private set; }
        public ICommand? ExportAllToJamaCommand { get; private set; }
        public ICommand? HelpCommand { get; private set; }
        public ICommand? ExportForChatGptCommand { get; private set; }
        public ICommand? ExportSelectedForChatGptCommand { get; private set; }
        public ICommand? ToggleAutoExportCommand { get; private set; }
        public ICommand? OpenChatGptExportCommand { get; private set; }

        // Analysis Commands
        public ICommand? AnalyzeUnanalyzedCommand { get; private set; }
        public ICommand? ReAnalyzeModifiedCommand { get; private set; }
        public ICommand? ImportAdditionalCommand { get; private set; }
        public ICommand? AnalyzeRequirementsCommand { get; private set; }
        public ICommand? BatchAnalyzeCommand { get; private set; }
        
        // ChatGPT Analysis Import Commands
        public ICommand? ImportStructuredAnalysisCommand { get; private set; }
        public ICommand? PasteChatGptAnalysisCommand { get; private set; }
        public ICommand? GenerateLearningPromptCommand { get; private set; }
        public ICommand? SetupLlmWorkspaceCommand { get; private set; }
        public ICommand? GenerateAnalysisCommandCommand { get; private set; }
        public ICommand? GenerateTestCaseCommandCommand { get; private set; }

        // Selected menu section - UNIFIED: delegates to NavigationMediator
        public string? SelectedMenuSection
        {
            get => _viewAreaCoordinator.NavigationMediator.CurrentSection;
            set
            {
                if (_viewAreaCoordinator.NavigationMediator.CurrentSection != value)
                {
                    _viewAreaCoordinator.NavigationMediator.NavigateToSection(value ?? "");
                    OnPropertyChanged(); // Maintain legacy binding compatibility
                    // TODO: Remove OnSelectedMenuSectionChanged after migration complete
                    OnSelectedMenuSectionChanged(value);
                }
            }
        }

        // Dirty state tracking for unsaved changes
        private bool _isDirty;
        public bool IsDirty
        {
            get => _isDirty;
            set
            {
                if (_isDirty != value)
                {
                    TestCaseEditorApp.Services.Logging.Log.Debug($"[MainViewModel] IsDirty changing from {_isDirty} to {value}. Stack: {Environment.StackTrace}");
                }
                if (SetProperty(ref _isDirty, value))
                {
                    UpdateWindowTitle();
                }
            }
        }

        private void UpdateWindowTitle()
        {
            // Update workspace header to show dirty state (asterisk)
            if (_workspaceHeaderViewModel != null)
            {
                var baseName = string.IsNullOrEmpty(_workspaceHeaderViewModel.WorkspaceName)
                    ? "Test Case Editor"
                    : _workspaceHeaderViewModel.WorkspaceName;
                _workspaceHeaderViewModel.Title = IsDirty ? $"{baseName} *" : baseName;
            }
        }

        // WrapOnNextWithoutTestCase required by ITestCaseGenerator_Navigator
        private bool _wrapOnNextWithoutTestCase;
        public bool WrapOnNextWithoutTestCase
        {
            get => _wrapOnNextWithoutTestCase;
            set => SetProperty(ref _wrapOnNextWithoutTestCase, value);
        }

        // IsLlmBusy required by ITestCaseGenerator_Navigator
        private bool _isLlmBusy;
        public bool IsLlmBusy
        {
            get => _isLlmBusy;
            set
            {
                TestCaseEditorApp.Services.Logging.Log.Debug($"[MainViewModel] IsLlmBusy changing from {_isLlmBusy} to {value}");
                if (SetProperty(ref _isLlmBusy, value))
                {
                    TestCaseEditorApp.Services.Logging.Log.Debug($"[MainViewModel] IsLlmBusy changed to {value}, notifying navigation commands");
                    // Notify navigation commands to re-evaluate CanExecute
                    NextRequirementCommand?.NotifyCanExecuteChanged();
                    PreviousRequirementCommand?.NotifyCanExecuteChanged();
                    NextWithoutTestCaseCommand?.NotifyCanExecuteChanged();
                    
                    // Notify analysis commands that depend on current requirement
                    ((RelayCommand?)AnalyzeRequirementsCommand)?.NotifyCanExecuteChanged();
                    
                    // Update workspace header CanReAnalyze state
                    if (_workspaceHeaderViewModel != null)
                    {
                        _workspaceHeaderViewModel.CanReAnalyze = (CurrentRequirement != null && !value);
                        ((AsyncRelayCommand?)_workspaceHeaderViewModel.ReAnalyzeCommand)?.NotifyCanExecuteChanged();
                    }
                }
            }
        }

        // -------------------------
        // Constructors
        // -------------------------

        // Simple constructor for design-time / fallback scenarios.
        // Design-time constructor
        public MainViewModel()
            : this(
                  applicationServices: new ApplicationServices(
                      requirementService: new DesignTimeServices.NoOpRequirementService(),
                      persistenceService: new DesignTimeServices.NoOpPersistenceService(),
                      fileDialogService: new DesignTimeServices.NoOpFileDialogService(),
                      toastService: new ToastNotificationService(System.Windows.Threading.Dispatcher.CurrentDispatcher),
                      notificationService: new NotificationService(new ToastNotificationService(System.Windows.Threading.Dispatcher.CurrentDispatcher)),
                      anythingLLMService: new AnythingLLMService(),
                      chatGptExportService: new ChatGptExportService()
                  ),
                  viewModelFactory: new ViewModelFactory(new ApplicationServices(
                      requirementService: new DesignTimeServices.NoOpRequirementService(),
                      persistenceService: new DesignTimeServices.NoOpPersistenceService(),
                      fileDialogService: new DesignTimeServices.NoOpFileDialogService(),
                      toastService: new ToastNotificationService(System.Windows.Threading.Dispatcher.CurrentDispatcher),
                      notificationService: new NotificationService(new ToastNotificationService(System.Windows.Threading.Dispatcher.CurrentDispatcher)),
                      anythingLLMService: new AnythingLLMService(),
                      chatGptExportService: new ChatGptExportService()
                  )),
                  services: new DesignTimeServices.SimpleServiceProviderStub())
        {
            // parameterless delegates to full constructor (no-op services)
        }

        // DI-friendly constructor. logger parameters are optional.
        public MainViewModel(
            IApplicationServices applicationServices,
            IViewModelFactory viewModelFactory,
            IWorkspaceManagementMediator? workspaceManagementMediator = null,
            LLMServiceManagementViewModel? llmServiceManagement = null,
            RequirementProcessingViewModel? requirementProcessing = null,
            UIModalManagementViewModel? uiModalManagement = null,
            WorkspaceManagementViewModel? workspaceManagement = null,
            NavigationHeaderManagementViewModel? navigationHeaderManagement = null,
            RequirementAnalysisManagementViewModel? requirementAnalysisManagement = null,
            IServiceProvider? services = null)
        {
            // Store core services
            _applicationServices = applicationServices ?? throw new ArgumentNullException(nameof(applicationServices));
            _viewModelFactory = viewModelFactory ?? throw new ArgumentNullException(nameof(viewModelFactory));
            _services = services ?? new DesignTimeServices.SimpleServiceProviderStub();
            
            // Initialize unified navigation system
            _viewAreaCoordinator = _viewModelFactory.CreateViewAreaCoordinator();
            
            // Subscribe to navigation mediator events to update legacy properties
            _viewAreaCoordinator.NavigationMediator.Subscribe<NavigationEvents.HeaderChanged>(e => OnPropertyChanged(nameof(ActiveHeader)));
            _viewAreaCoordinator.NavigationMediator.Subscribe<NavigationEvents.ContentChanged>(e => OnPropertyChanged(nameof(CurrentStepViewModel)));
            _viewAreaCoordinator.NavigationMediator.Subscribe<NavigationEvents.SectionChanged>(e => OnPropertyChanged(nameof(SelectedMenuSection)));
            
            // Subscribe to ViewAreaCoordinator changes to forward property notifications for UI binding
            
            // Extract commonly used services for convenience
            _requirementService = _applicationServices.RequirementService;
            _persistence = _applicationServices.PersistenceService;
            _fileDialog = _applicationServices.FileDialogService;
            _toastService = _applicationServices.ToastService;
            _notificationService = _applicationServices.NotificationService;
            _anythingLLMService = _applicationServices.AnythingLLMService;
            _chatGptExportService = _applicationServices.ChatGptExportService;
            _logger = _applicationServices.LoggerFactory?.CreateLogger<MainViewModel>();

            // Initialize domain ViewModels
            _workspaceManagementMediator = workspaceManagementMediator;
            if (_workspaceManagementMediator != null)
            {
                SubscribeToWorkspaceManagementEvents();
            }
            
            _llmServiceManagement = llmServiceManagement;
            _llmServiceManagement?.Initialize(this);
            
            _requirementProcessing = requirementProcessing;
            _requirementProcessing?.Initialize(this);
            
            _uiModalManagement = uiModalManagement;
            _uiModalManagement?.Initialize(this);
            
            _workspaceManagement = workspaceManagement;
            _workspaceManagement?.Initialize(this);

            _navigationHeaderManagement = navigationHeaderManagement;
            _navigationHeaderManagement?.Initialize(this);
            
            _requirementAnalysisManagement = requirementAnalysisManagement;
            _requirementAnalysisManagement?.Initialize(this);

            // LEGACY: Create ViewModels through factory for backward compatibility
            _workspaceHeaderViewModel = _viewAreaCoordinator.HeaderArea.ActiveHeader as WorkspaceHeaderViewModel ?? 
                                       _viewModelFactory.CreateWorkspaceHeaderViewModel();
            Navigation = _viewModelFactory.CreateNavigationViewModel();
            
            // Initialize workflows with proper event handling
            ImportWorkflow = _viewModelFactory.CreateImportWorkflowViewModel();
            ImportWorkflow.WorkflowCompleted += OnImportRequirementsWorkflowCompleted;
            ImportWorkflow.WorkflowCancelled += OnImportRequirementsWorkflowCancelled;
            
            NewProjectWorkflow = _viewModelFactory.CreateNewProjectWorkflowViewModel();
            NewProjectWorkflow.ProjectCreated += OnNewProjectCreated;
            NewProjectWorkflow.ProjectCancelled += OnNewProjectCancelled;

            // Initialize header instances through factory
            _testCaseGeneratorHeader = _viewModelFactory.CreateTestCaseGeneratorHeaderViewModel(this);

            // Initialize shared ViewModels for menu access
            _questionsViewModel = new TestCaseGenerator_QuestionsVM(_persistence, null, _testCaseGeneratorHeader, this);
            _assumptionsViewModel = new TestCaseGenerator_AssumptionsVM(_testCaseGeneratorHeader, this);

            // Complete initialization as in original constructor
            if (_testCaseGeneratorHeader != null)
            {
                _testCaseGeneratorHeader.RequirementDescription = "DIAG: description visible";
                _testCaseGeneratorHeader.RequirementMethod = "DIAG: method (string)";
                // If the VM exposes RequirementMethodEnum and you don't know the enum type,
                // set it via reflection to the first enum value (best-effort):
                var prop = _testCaseGeneratorHeader.GetType().GetProperty("RequirementMethodEnum");
                if (prop != null)
                {
                    var enumType = prop.PropertyType;
                    if (enumType.IsEnum)
                    {
                        var first = Enum.GetValues(enumType).GetValue(0);
                        prop.SetValue(_testCaseGeneratorHeader, first);
                    }
                }
                ActiveHeader = _testCaseGeneratorHeader; // ensure it's visible while debugging
            }

            // Default active header is workspace header
            ActiveHeader = _workspaceHeaderViewModel;

            // Wire collection change notifications (preserve the ObservableCollection instance)
            Requirements.CollectionChanged += RequirementsOnCollectionChanged;
            _requirementsCollectionHooked = true;

            // Subscribe to AnythingLLM status updates via mediator
            AnythingLLMMediator.StatusUpdated += OnAnythingLLMStatusFromMediator;

            // Initialize auto-save timer
            InitializeAutoSave();

            if (_testCaseGeneratorHeader != null)
            {
                _testCaseGeneratorHeader.RequirementDescription = "DIAG: description visible";
                _testCaseGeneratorHeader.RequirementMethod = "DIAG: method (string)";
                // If the VM exposes RequirementMethodEnum and you don't know the enum type,
                // set it via reflection to the first enum value (best-effort):
                var prop = _testCaseGeneratorHeader.GetType().GetProperty("RequirementMethodEnum");
                if (prop != null)
                {
                    var enumType = prop.PropertyType;
                    if (enumType.IsEnum)
                    {
                        var first = Enum.GetValues(enumType).GetValue(0);
                        prop.SetValue(_testCaseGeneratorHeader, first);
                    }
                }
                ActiveHeader = _testCaseGeneratorHeader; // ensure it's visible while debugging
            }

            // Default active header is workspace header
            ActiveHeader = _workspaceHeaderViewModel;

            // Wire collection change notifications (preserve the ObservableCollection instance)
            Requirements.CollectionChanged += RequirementsOnCollectionChanged;
            _requirementsCollectionHooked = true;

            // Subscribe to AnythingLLM status updates via mediator
            AnythingLLMMediator.StatusUpdated += OnAnythingLLMStatusFromMediator;

            // Initialize auto-save timer
            InitializeAutoSave();

            // Initialize recent files service
            try { _recentFilesService = new RecentFilesService(); } catch { }
            
            // Load persisted user preference for auto-analysis on import (default: true)
            try
            {
                if (_persistence != null && _persistence.Exists("AutoAnalyzeOnImport"))
                {
                    var val = _persistence.Load<bool>("AutoAnalyzeOnImport");
                    _autoAnalyzeOnImport = val;
                }
            }
            catch { /* ignore persistence errors */ }

            // Load persisted user preference for auto-export for ChatGPT (default: false)
            try
            {
                if (_persistence != null && _persistence.Exists("AutoExportForChatGpt"))
                {
                    var val = _persistence.Load<bool>("AutoExportForChatGpt");
                    _autoExportForChatGpt = val;
                }
            }
            catch { /* ignore persistence errors */ }

            // TODO: Commands need to be initialized - complex initialization extracted for now
            InitializeCommands();

            // Populate UI steps (factories create step VMs)
            InitializeSteps();

            // Start with initial state view instead of no content
            CurrentStepViewModel = InitialStateViewModel;

            // Ensure header wiring is consistent
            TryWireDynamicTestCaseGenerator();
            WireHeaderSubscriptions();

            // Check AnythingLLM status on startup and integrate with LlmConnectionManager
            // Only do this for runtime instances, not design-time
            if (!System.ComponentModel.DesignerProperties.GetIsInDesignMode(new System.Windows.DependencyObject()))
            {
                _ = Task.Run(async () => await InitializeAnythingLLMAsync());
            }

            _logger?.LogDebug("MainViewModel constructed");
        }

        /// <summary>
        /// Initializes RAG workspace for the current project workspace.
        /// Creates or finds AnythingLLM workspace and loads documents for RAG functionality.
        /// </summary>
        private async Task InitializeRagForWorkspaceAsync()
        {
            if (CurrentWorkspace == null || string.IsNullOrEmpty(WorkspacePath))
            {
                TestCaseEditorApp.Services.Logging.Log.Debug("[RAG] No workspace loaded, skipping RAG initialization");
                return;
            }

            await (_llmServiceManagement?.InitializeRagForWorkspaceAsync(CurrentWorkspace, WorkspacePath, _workspaceHeaderViewModel, (msg, duration, error) => SetTransientStatus(msg, duration, error)) ?? Task.CompletedTask);
        }

        /// <summary>
        /// Initializes AnythingLLM connection and updates the LlmConnectionManager with the status.
        /// This integrates with the existing LLM connection system.
        /// </summary>
        private async Task InitializeAnythingLLMAsync()
        {
            await (_llmServiceManagement?.InitializeAnythingLLMServiceAsync() ?? Task.CompletedTask);
        }
        
        /// <summary>
        /// Handles AnythingLLM status updates from mediator to keep MainViewModel properties in sync
        /// </summary>
        private void OnAnythingLLMStatusFromMediator(AnythingLLMStatus status)
        {
            Application.Current?.Dispatcher.BeginInvoke(() =>
            {
                IsAnythingLLMAvailable = status.IsAvailable;
                IsAnythingLLMStarting = status.IsStarting;
                AnythingLLMStatusMessage = status.StatusMessage;
            });
        }
        
        /// <summary>
        /// Handles real-time status updates from AnythingLLM service during startup
        /// </summary>
        private void OnAnythingLLMStatusUpdated(string statusMessage)
        {
            Application.Current.Dispatcher.BeginInvoke(() =>
            {
                var status = new AnythingLLMStatus
                {
                    IsAvailable = false, // Still starting if we're getting status updates
                    IsStarting = !string.IsNullOrEmpty(statusMessage) && 
                               statusMessage != "AnythingLLM â€” connected" && 
                               statusMessage != "AnythingLLM â€” disconnected",
                    StatusMessage = statusMessage
                };
                AnythingLLMMediator.NotifyStatusUpdated(status);
            });
        }

        private void InitializeSteps()
        {
            _workspaceManagement?.InitializeSteps();
        }

        private void InitializeCommands()
        {
            // Modal Management Commands
            CloseModalCommand = new RelayCommand(() => CloseModal());
            
            // Import/Export Commands
            ImportWordCommand = new AsyncRelayCommand(async () => await ImportFromPathAsync("", false));
            QuickImportCommand = new AsyncRelayCommand(async () => await ImportFromPathAsync("", false));
            LoadWorkspaceCommand = new RelayCommand(() => LoadWorkspace());
            SaveWorkspaceCommand = new RelayCommand(() => SaveWorkspace());
            ReloadCommand = new AsyncRelayCommand(ReloadAsync);
            
            // Analysis Commands (delegate to domain ViewModels)
            AnalyzeUnanalyzedCommand = _requirementAnalysisManagement?.AnalyzeUnanalyzedCommand ?? new RelayCommand(() => { });
            ReAnalyzeModifiedCommand = _requirementAnalysisManagement?.ReAnalyzeModifiedCommand ?? new RelayCommand(() => { });
            AnalyzeRequirementsCommand = _requirementAnalysisManagement?.AnalyzeCurrentRequirementCommand ?? new RelayCommand(() => { });
            BatchAnalyzeCommand = _requirementAnalysisManagement?.BatchAnalyzeAllRequirementsCommand ?? new RelayCommand(() => { });
            
            // ChatGPT Export Commands
            ExportForChatGptCommand = new RelayCommand(() => { /* TODO: Wire to ChatGptExportAnalysisViewModel */ }, () => CurrentRequirement != null);
            ExportSelectedForChatGptCommand = new RelayCommand(() => { /* TODO: Wire to ChatGptExportAnalysisViewModel */ });
            ExportAllToJamaCommand = new RelayCommand(() => TryInvokeExportAllToJama());
            ToggleAutoExportCommand = new RelayCommand(() => AutoExportForChatGpt = !AutoExportForChatGpt);
            OpenChatGptExportCommand = new RelayCommand(() => { /* TODO: Wire to open export file */ });
            
            // LLM Commands 
            ImportStructuredAnalysisCommand = new RelayCommand(() => { /* TODO: Wire to domain VM */ });
            PasteChatGptAnalysisCommand = new RelayCommand(() => PasteChatGptAnalysis());
            GenerateLearningPromptCommand = _requirementGeneration?.GenerateLearningPromptCommand ?? new RelayCommand(() => { });
            SetupLlmWorkspaceCommand = new RelayCommand(() => SetupLlmWorkspace());
            GenerateAnalysisCommandCommand = _requirementGeneration?.GenerateAnalysisCommandCommand ?? new RelayCommand(() => { });
            GenerateTestCaseCommandCommand = _requirementGeneration?.GenerateTestCaseCommandCommand ?? new RelayCommand(() => { });
            
            // Additional Commands
            ImportAdditionalCommand = new RelayCommand(() => { /* TODO: Wire to domain VM */ });
            HelpCommand = new RelayCommand(() => TryInvokeHelp());
        }

        // SelectedStep property
        private StepDescriptor? _selectedStep;
        public StepDescriptor? SelectedStep
        {
            get => _selectedStep;
            set => HandleSelectedStepChange(value);
        }

        // Initial state view model for when no content is loaded
        private InitialStateViewModel? _initialStateViewModel;
        private InitialStateViewModel InitialStateViewModel
        {
            get
            {
                if (_initialStateViewModel == null)
                {
                    _initialStateViewModel = new InitialStateViewModel();
                }
                return _initialStateViewModel;
            }
        }

        // -----------------------------
        // Header wiring and helpers
        // -----------------------------

        // Insert this method into MainViewModel.cs (near other header helpers)
        private void OnSelectedMenuSectionChanged(string? value)
        {
            _navigationHeaderManagement?.OnSelectedMenuSectionChanged(value);
        }

        // TODO: Extract to NavigationHeaderManagementViewModel - method moved for Round 7

        // TODO: Extract to NavigationHeaderManagementViewModel - method moved for Round 7

        private void CreateAndAssignTestCaseGeneratorHeader()
        {
            _navigationHeaderManagement?.CreateAndAssignTestCaseGeneratorHeader();
        }

        private void WireHeaderSubscriptions()
        {
            _navigationHeaderManagement?.WireHeaderSubscriptions();
        }
        
        private void Header_PropertyChanged(object? sender, PropertyChangedEventArgs e)
        {
            _navigationHeaderManagement?.Header_PropertyChanged(sender, e);
        }

        private void UnwireHeaderSubscriptions()
        {
            _navigationHeaderManagement?.UnwireHeaderSubscriptions();
        }

        private void Requirements_CollectionChanged(object? sender, NotifyCollectionChangedEventArgs e)
        {
            try
            {
                _testCaseGeneratorHeader?.UpdateRequirements(Requirements);
            }
            catch { /* swallow */ }
        }

        private void LlmConnectionManager_ConnectionChanged(bool connected)
        {
            if (_testCaseGeneratorHeader == null) return;
            try { _testCaseGeneratorHeader.IsLlmConnected = connected; } catch { }
        }

        private void TestCaseGenerator_PropertyChanged(object? sender, PropertyChangedEventArgs e)
        {
            if (_testCaseGeneratorHeader == null) return;

            if (string.Equals(e.PropertyName, "IsLlmAvailable", StringComparison.Ordinal)
                || string.Equals(e.PropertyName, "IsLlmBusy", StringComparison.Ordinal))
            {
                try
                {
                    bool connected = false;
                    try
                    {
                        var tcg = GetTestCaseGeneratorInstance();
                        if (tcg != null)
                        {
                            var avProp = tcg.GetType().GetProperty("IsLlmAvailable", BindingFlags.Public | BindingFlags.Instance);
                            var busyProp = tcg.GetType().GetProperty("IsLlmBusy", BindingFlags.Public | BindingFlags.Instance);
                            var isAvailable = avProp != null && avProp.GetValue(tcg) is bool bav && bav;
                            var isBusy = busyProp != null && busyProp.GetValue(tcg) is bool bbusy && bbusy;
                            connected = isAvailable && !isBusy;
                        }
                    }
                    catch { connected = false; }

                    _testCaseGeneratorHeader.IsLlmConnected = connected;
                }
                catch { /* swallow */ }
            }
        }

        private void Header_Requirements_CollectionChanged(object? sender, NotifyCollectionChangedEventArgs e)
        {
            if (e.OldItems != null)
            {
                foreach (Requirement r in e.OldItems) TryUnwireRequirementForHeader(r);
            }
            if (e.NewItems != null)
            {
                foreach (Requirement r in e.NewItems) TryWireRequirementForHeader(r);
            }
            _testCaseGeneratorHeader?.UpdateRequirements(Requirements);
        }

        private void TryWireRequirementForHeader(Requirement? r)
        {
            if (r == null) return;
            try { r.PropertyChanged += Requirement_ForHeader_PropertyChanged; } catch { }
        }

        private void TryUnwireRequirementForHeader(Requirement? r)
        {
            if (r == null) return;
            try { r.PropertyChanged -= Requirement_ForHeader_PropertyChanged; } catch { }
        }

        private void Requirement_ForHeader_PropertyChanged(object? sender, PropertyChangedEventArgs e)
        {
            if (e.PropertyName == nameof(Requirement.CurrentResponse) ||
                e.PropertyName == nameof(Requirement.GeneratedTestCases))
            {
                _testCaseGeneratorHeader?.UpdateRequirements(Requirements);
            }
        }

        private void UpdateTestCaseGeneratorHeaderFromState()
        {
            var h = _testCaseGeneratorHeader;
            if (h == null) return;

            try
            {
                string? wsName = null;
                try
                {
                    if (!string.IsNullOrWhiteSpace(WorkspacePath))
                        wsName = Path.GetFileName(WorkspacePath);
                    else if (CurrentWorkspace?.SourceDocPath != null)
                        wsName = Path.GetFileName(CurrentWorkspace.SourceDocPath);
                }
                catch { wsName = null; }
                h.WorkspaceName = string.IsNullOrWhiteSpace(wsName) ? "Workspace" : wsName;

                h.CurrentRequirementName = CurrentRequirement?.Name ?? CurrentRequirement?.Item ?? string.Empty;

                int count = 0;
                try
                {
                    count = Requirements?.Count(r =>
                    {
                        try
                        {
                            return (r != null) && ((r.GeneratedTestCases != null && r.GeneratedTestCases.Count > 0) || r.HasGeneratedTestCase);
                        }
                        catch { return false; }
                    }) ?? 0;
                }
                catch { count = 0; }
                h.RequirementsWithTestCasesCount = count;

                try
                {
                    bool fallbackConnected = false;
                    try
                    {
                        var tcg = GetTestCaseGeneratorInstance();
                        if (tcg != null)
                        {
                            var avProp = tcg.GetType().GetProperty("IsLlmAvailable", BindingFlags.Public | BindingFlags.Instance);
                            var busyProp = tcg.GetType().GetProperty("IsLlmBusy", BindingFlags.Public | BindingFlags.Instance);
                            var isAvailable = avProp != null && avProp.GetValue(tcg) is bool bav && bav;
                            var isBusy = busyProp != null && busyProp.GetValue(tcg) is bool bbusy && bbusy;
                            fallbackConnected = isAvailable && !isBusy;
                        }
                    }
                    catch { fallbackConnected = false; }

                    h.IsLlmConnected = LlmConnectionManager.IsConnected || fallbackConnected;
                }
                catch { /* ignore */ }
            }
            catch { /* ignore */ }
        }

        public void SetLlmConnection(bool connected)
        {
            LlmConnectionManager.SetConnected(connected);
        }

        private void Header_OpenRequirements()
        {
            try
            {
                var reqStep = TestCaseGeneratorSteps.FirstOrDefault(s => string.Equals(s.Id, "requirements", StringComparison.OrdinalIgnoreCase));
                if (reqStep != null) SelectedStep = reqStep;
                SelectedMenuSection = "Requirements";
                SetTransientStatus("Opened requirements.", 2);
            }
            catch (Exception ex)
            {
                _logger?.LogWarning(ex, "[Header_OpenRequirements] failed");
                SetTransientStatus($"Failed to open requirements: {ex.Message}", blockingError: true);
            }
        }

        private void Header_OpenWorkspace()
        {
            try { TryInvokeLoadWorkspace(); }
            catch (Exception ex)
            {
                _logger?.LogWarning(ex, "[Header_OpenWorkspace] failed");
                SetTransientStatus($"Failed to open workspace: {ex.Message}", blockingError: true);
            }
        }

        // ----------------- helpers that avoid compile-time coupling -----------------
        public object? GetTestCaseGeneratorInstance()
        {
            try
            {
                var prop = this.GetType().GetProperty("TestCaseGenerator", BindingFlags.Public | BindingFlags.Instance | BindingFlags.IgnoreCase);
                return prop?.GetValue(this);
            }
            catch { return null; }
        }

        private void TryWireDynamicTestCaseGenerator()
        {
            try
            {
                var tcg = GetTestCaseGeneratorInstance();
                if (tcg is INotifyPropertyChanged inpc && !ReferenceEquals(inpc, _linkedTestCaseGeneratorInpc))
                {
                    if (_linkedTestCaseGeneratorInpc != null)
                    {
                        _linkedTestCaseGeneratorInpc.PropertyChanged -= TestCaseGenerator_PropertyChanged;
                        _linkedTestCaseGeneratorInpc = null;
                    }

                    inpc.PropertyChanged += TestCaseGenerator_PropertyChanged;
                    _linkedTestCaseGeneratorInpc = inpc;
                }
            }
            catch { /* ignore */ }
        }

        private void TryInvokeSaveWorkspace()
        {
            try
            {
                // Store dirty state to avoid recursive updates
                var wasDirty = _isDirty;
                
                var cmdProp = this.GetType().GetProperty("SaveWorkspaceCommand", BindingFlags.Public | BindingFlags.Instance | BindingFlags.IgnoreCase)
                            ?? this.GetType().GetProperty("SaveCommand", BindingFlags.Public | BindingFlags.Instance | BindingFlags.IgnoreCase);
                if (cmdProp != null && cmdProp.GetValue(this) is ICommand cmd && cmd.CanExecute(null))
                {
                    cmd.Execute(null);
                    if (wasDirty) _isDirty = false; // Clear dirty flag directly without triggering property change
                    return;
                }

                var m = this.GetType().GetMethod("SaveWorkspace", BindingFlags.Public | BindingFlags.Instance | BindingFlags.IgnoreCase)
                     ?? this.GetType().GetMethod("Save", BindingFlags.Public | BindingFlags.Instance | BindingFlags.IgnoreCase);
                if (m != null)
                {
                    m.Invoke(this, Array.Empty<object>());
                    if (wasDirty) _isDirty = false; // Clear dirty flag directly without triggering property change
                    return;
                }
            }
            catch { /* ignore */ }
        }

        private void TryInvokeLoadWorkspace()
        {
            try
            {
                var cmdProp = this.GetType().GetProperty("LoadWorkspaceCommand", BindingFlags.Public | BindingFlags.Instance | BindingFlags.IgnoreCase)
                            ?? this.GetType().GetProperty("OpenWorkspaceCommand", BindingFlags.Public | BindingFlags.Instance | BindingFlags.IgnoreCase);
                if (cmdProp != null && cmdProp.GetValue(this) is ICommand cmd && cmd.CanExecute(null))
                {
                    cmd.Execute(null);
                    return;
                }

                var m = this.GetType().GetMethod("LoadWorkspace", BindingFlags.Public | BindingFlags.Instance | BindingFlags.IgnoreCase)
                     ?? this.GetType().GetMethod("OpenWorkspace", BindingFlags.Public | BindingFlags.Instance | BindingFlags.IgnoreCase);
                if (m != null)
                {
                    m.Invoke(this, Array.Empty<object>());
                    return;
                }
            }
            catch { /* ignore */ }
        }

        private void TryInvokeExportAllToJama()
        {
            try
            {
                var cmdProp = this.GetType().GetProperty("ExportAllToJamaCommand", BindingFlags.Public | BindingFlags.Instance | BindingFlags.IgnoreCase);
                if (cmdProp != null && cmdProp.GetValue(this) is ICommand cmd && cmd.CanExecute(null))
                {
                    cmd.Execute(null);
                    return;
                }

                var m = this.GetType().GetMethod("ExportAllToJama", BindingFlags.Public | BindingFlags.Instance | BindingFlags.IgnoreCase);
                if (m != null)
                {
                    m.Invoke(this, Array.Empty<object>());
                    return;
                }
            }
            catch (Exception ex)
            {
                _logger?.LogWarning(ex, "TryInvokeExportAllToJama failed");
            }

            SetTransientStatus("Export to Jama is not available.", 3);
        }

        // TODO: Extract to RequirementImportExportViewModel - method moved for Round 6

        // TODO: Extract to RequirementImportExportViewModel - method moved for Round 6

        private void TryInvokeHelp()
        {
            try
            {
                var cmdProp = this.GetType().GetProperty("HelpCommand", BindingFlags.Public | BindingFlags.Instance | BindingFlags.IgnoreCase);
                if (cmdProp != null && cmdProp.GetValue(this) is ICommand cmd && cmd.CanExecute(null))
                {
                    cmd.Execute(null);
                    return;
                }

                var m = this.GetType().GetMethod("ShowHelp", BindingFlags.Public | BindingFlags.Instance | BindingFlags.IgnoreCase)
                     ?? this.GetType().GetMethod("OpenHelp", BindingFlags.Public | BindingFlags.Instance | BindingFlags.IgnoreCase);
                if (m != null)
                {
                    m.Invoke(this, Array.Empty<object>());
                    return;
                }
            }
            catch (Exception ex)
            {
                _logger?.LogWarning(ex, "TryInvokeHelp failed");
            }

            SetTransientStatus("Help is not available.", 3);
        }

        // -----------------------------
        // Collection / navigation helpers
        // -----------------------------
        internal void RequirementsOnCollectionChanged(object? sender, NotifyCollectionChangedEventArgs e)
        {
            OnPropertyChanged(nameof(TotalRequirementsCount));
            OnPropertyChanged(nameof(RequirementPositionDisplay));
            _requirementsNavigator?.NotifyCurrentRequirementChanged();
        }

        public int TotalRequirementsCount => Requirements?.Count ?? 0;

        public string RequirementPositionDisplay =>
            Requirements == null || Requirements.Count == 0 || CurrentRequirement == null
                ? string.Empty
                : $"{Requirements.IndexOf(CurrentRequirement) + 1} of {Requirements.Count}";

        public void CommitPendingEdits() => Keyboard.ClearFocus();

        // TODO: Extract to RequirementImportExportViewModel - method moved for Round 6
        
        // TODO: Extract to RequirementImportExportViewModel - method moved for Round 6

        public Task ReloadAsync()
        {
            if (string.IsNullOrWhiteSpace(CurrentSourcePath))
            {
                SetTransientStatus("No source loaded to reload.", 3);
                return Task.CompletedTask;
            }
            return ImportFromPathAsync(CurrentSourcePath!, replace: true);
        }

        // Quick save to existing workspace path
        public void SaveWorkspace()
        {
            TestCaseEditorApp.Services.Logging.Log.Info($"[SaveWorkspace] Quick save called. WorkspacePath='{WorkspacePath ?? "<null>"}'");
            if (string.IsNullOrWhiteSpace(WorkspacePath))
            {
                TestCaseEditorApp.Services.Logging.Log.Info("[SaveWorkspace] No existing path, delegating to SaveAs");
                // No existing path, delegate to SaveAs
                _ = SaveWorkspaceAsync();
                return;
            }

            if (Requirements == null || Requirements.Count == 0)
            {
                SetTransientStatus("Nothing to save.", 2);
                return;
            }

            var ws = new Workspace
            {
                SourceDocPath = CurrentSourcePath,
                Requirements = Requirements.ToList()
            };

            try
            {
                TestCaseEditorApp.Services.WorkspaceFileManager.Save(WorkspacePath!, ws);
                // Log detailed post-save diagnostics to help locate the written file
                LogPostSaveDiagnostics(WorkspacePath!);
                CurrentWorkspace = ws;
                IsDirty = false;
                HasUnsavedChanges = false;
                
                // Track in recent files
                try { _recentFilesService?.AddRecentFile(WorkspacePath!); } catch { }
                
                SetTransientStatus($"Saved: {Path.GetFileName(WorkspacePath)}", 3);
            }
            catch (Exception ex)
            {
                _notificationService.ShowError($"Failed to save workspace: {ex.Message}", 8);
            }
        }

        // Save As - prompts for location
        public async Task SaveWorkspaceAsync()
        {
            // Ensure async methods contain an await to satisfy analyzer when method is mostly synchronous
            await Task.CompletedTask;
            if (Requirements == null || Requirements.Count == 0)
            {
                SetTransientStatus("Nothing to save.", 2);
                return;
            }

            var suggested = $"{(string.IsNullOrWhiteSpace(Path.GetFileNameWithoutExtension(WordFilePath)) ? "Workspace" : Path.GetFileNameWithoutExtension(WordFilePath))}.tcex.json";
            var defaultFolder = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.Desktop), "TestCaseEditorApp", "Workspaces");
            Directory.CreateDirectory(defaultFolder);

            TestCaseEditorApp.Services.Logging.Log.Info($"[MainViewModel] Showing SaveFile dialog. initialDirectory={defaultFolder}, suggestedFileName={suggested}");
            var chosen = _fileDialog.ShowSaveFile(
                title: "Save Workspace",
                suggestedFileName: suggested,
                filter: "Test Case Editor Session|*.tcex.json|JSON|*.json|All Files|*.*",
                defaultExt: ".tcex.json",
                initialDirectory: defaultFolder);

            TestCaseEditorApp.Services.Logging.Log.Debug($"[MainViewModel] File dialog returned: '{chosen ?? "NULL"}'");

            if (string.IsNullOrWhiteSpace(chosen))
            {
                SetTransientStatus("Save cancelled.", 2);
                return;
            }

            // If the dialog returned a folder path (or a path without a filename),
            // append the suggested filename so we save a file rather than attempting
            // to write to a directory.
            try
            {
                if (Directory.Exists(chosen) || string.IsNullOrWhiteSpace(Path.GetFileName(chosen)))
                {
                    chosen = Path.Combine(chosen, suggested);
                }

                // Ensure a file extension is present - default to the expected extension
                if (string.IsNullOrWhiteSpace(Path.GetExtension(chosen)))
                {
                    chosen = Path.ChangeExtension(chosen, ".tcex.json");
                }
            }
            catch (Exception ex)
            {
                // Defensive: if path normalization fails, cancel the save and inform the user
                TestCaseEditorApp.Services.Logging.Log.Debug($"[SaveWorkspaceAsync] Path normalization failed: {ex.Message}");
                MessageBox.Show($"Failed to determine save file path: {ex.Message}", "Save error", MessageBoxButton.OK, MessageBoxImage.Error);
                return;
            }

            WorkspacePath = chosen;
            TestCaseEditorApp.Services.Logging.Log.Debug($"[MainViewModel] Set WorkspacePath to: '{WorkspacePath}'");
            var ws = new Workspace
            {
                SourceDocPath = CurrentSourcePath,
                Requirements = Requirements.ToList()
            };

            try
            {
                // Log and show where we will save to help debug user-reported mismatches
                TestCaseEditorApp.Services.Logging.Log.Debug($"[SaveWorkspaceAsync] Saving workspace to: {chosen}");
                SetTransientStatus($"Saving workspace to: {chosen}", 2);

                TestCaseEditorApp.Services.WorkspaceFileManager.Save(WorkspacePath!, ws);
                // Log detailed post-save diagnostics to help locate the written file
                LogPostSaveDiagnostics(WorkspacePath!);
                CurrentWorkspace = ws;
                IsDirty = false;
                HasUnsavedChanges = false;
                
                // Track in recent files
                try { _recentFilesService?.AddRecentFile(WorkspacePath!); } catch { }
                
                SetTransientStatus($"Saved workspace: {Path.GetFileName(WorkspacePath)}", 4);
                TestCaseEditorApp.Services.Logging.Log.Debug($"[SaveWorkspaceAsync] Save complete: {WorkspacePath}");
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Failed to save workspace: {ex.Message}", "Save error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        public void LoadWorkspace()
        {
            var ofd = new OpenFileDialog
            {
                Title = "Open Saved Session",
                Filter = "Test Case Editor Session|*.tcex.json",
                DefaultExt = ".tcex.json",
                RestoreDirectory = true,
                InitialDirectory = !string.IsNullOrWhiteSpace(WorkspacePath) ? Path.GetDirectoryName(WorkspacePath) : Environment.GetFolderPath(Environment.SpecialFolder.Desktop)
            };

            if (ofd.ShowDialog() != true) return;

            LoadWorkspaceFromPath(ofd.FileName);
        }

        public void LoadWorkspaceFromPath(string filePath)
        {
            TestCaseEditorApp.Services.Logging.Log.Info($"[LoadWorkspace] Starting to load workspace from: {filePath}");
            
            if (string.IsNullOrWhiteSpace(filePath) || !File.Exists(filePath))
            {
                TestCaseEditorApp.Services.Logging.Log.Info($"[LoadWorkspace] Invalid file path or file doesn't exist: {filePath}");
                SetTransientStatus("Invalid workspace file path.", blockingError: true);
                return;
            }

            WorkspacePath = filePath;
            TestCaseEditorApp.Services.Logging.Log.Info($"[LoadWorkspace] Set WorkspacePath to: {WorkspacePath}");
            
            try
            {
                TestCaseEditorApp.Services.Logging.Log.Info($"[LoadWorkspace] Attempting to load workspace file...");
                var ws = TestCaseEditorApp.Services.WorkspaceFileManager.Load(WorkspacePath!);
                if (ws == null)
                {
                    TestCaseEditorApp.Services.Logging.Log.Info("[LoadWorkspace] Workspace file loaded but returned null");
                    SetTransientStatus("Failed to load workspace (file empty or invalid).", blockingError: true);
                    return;
                }

                TestCaseEditorApp.Services.Logging.Log.Info($"[LoadWorkspace] Successfully loaded workspace. Requirements count: {ws.Requirements?.Count ?? 0}");
                CurrentWorkspace = ws;
                
                // Track in recent files
                try { _recentFilesService?.AddRecentFile(WorkspacePath!); } catch { }
                
                TestCaseEditorApp.Services.Logging.Log.Info($"[LoadWorkspace] Clearing existing requirements and loading new ones...");
                Requirements.Clear();
                foreach (var r in ws.Requirements ?? Enumerable.Empty<Requirement>())
                    Requirements.Add(r);

                Requirement? firstFromView = null;
                try
                {
                    firstFromView = _requirementsNavigator?.RequirementsView?.Cast<Requirement>().FirstOrDefault();
                }
                catch { firstFromView = null; }

                CurrentRequirement = firstFromView ?? Requirements.FirstOrDefault();
                CurrentSourcePath = ws.SourceDocPath;
                
                TestCaseEditorApp.Services.Logging.Log.Info($"[LoadWorkspace] Workspace loading completed successfully. Current requirement: {CurrentRequirement?.GlobalId}");
                SetTransientStatus($"Opened workspace: {Path.GetFileName(WorkspacePath)} - {Requirements.Count} requirements", 4);
                HasUnsavedChanges = false;
                IsDirty = false;
                
                // Initialize RAG workspace for enhanced AI analysis
                _ = Task.Run(async () => await InitializeRagForWorkspaceAsync());
            }
            catch (Exception ex)
            {
                TestCaseEditorApp.Services.Logging.Log.Error(ex, $"[LoadWorkspace] Exception occurred while loading workspace: {ex.Message}");
                MessageBox.Show($"Failed to load workspace: {ex.Message}", "Load error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        /// <summary>
        /// Command to initialize RAG workspace manually
        /// </summary>
        public ICommand InitializeRagCommand => new RelayCommand(async () => await InitializeRagForWorkspaceAsync());

        // Navigation methods moved to NavigationHeaderManagementViewModel
        
        private bool CanReAnalyze()
        {
            return _requirementAnalysisManagement?.CanReAnalyze() ?? (CurrentRequirement != null && !IsLlmBusy);
        }
        
        private async Task ReAnalyzeRequirementAsync()
        {
            await Task.CompletedTask;
            try
            {
                var tcg = GetTestCaseGeneratorInstance();
                if (tcg == null) return;
                
                // Get the AnalysisVM from TestCaseGenerator_VM
                var analysisVmProp = tcg.GetType().GetProperty("AnalysisVM", BindingFlags.Public | BindingFlags.Instance);
                if (analysisVmProp == null) return;
                
                var analysisVm = analysisVmProp.GetValue(tcg);
                if (analysisVm == null) return;
                
                // Switch to Analysis tab first
                var isAnalysisSelectedProp = tcg.GetType().GetProperty("IsAnalysisSelected", BindingFlags.Public | BindingFlags.Instance);
                isAnalysisSelectedProp?.SetValue(tcg, true);
                
                // Trigger analysis
                var analyzeCommandProp = analysisVm.GetType().GetProperty("AnalyzeRequirementCommand", BindingFlags.Public | BindingFlags.Instance);
                if (analyzeCommandProp?.GetValue(analysisVm) is ICommand analyzeCommand && analyzeCommand.CanExecute(null))
                {
                    analyzeCommand.Execute(null);
                }
            }
            catch (Exception ex)
            {
                TestCaseEditorApp.Services.Logging.Log.Debug($"[MainViewModel] Re-Analyze error: {ex}");
            }
        }
        
        // TODO: Extract to NavigationHeaderManagementViewModel - method moved for Round 7

        // TODO: Extract to NavigationHeaderManagementViewModel - method moved for Round 7

        // TODO: Extract to NavigationHeaderManagementViewModel - method moved for Round 7

        // Requirement wiring helpers
        private Requirement? _prevReq;
        private void UnhookOldRequirement()
        {
            if (_prevReq != null) _prevReq.PropertyChanged -= CurrentRequirement_PropertyChanged;
            _prevReq = null;
        }

        private void HookNewRequirement(Requirement? r)
        {
            if (r != null) { _prevReq = r; _prevReq.PropertyChanged += CurrentRequirement_PropertyChanged; }
        }

        // CurrentRequirement change handling
        /// <summary>
        /// Save data before navigating to a new requirement or view.
        /// Only saves if workspace is dirty (orange unsaved state).
        /// Checks the current view type and saves appropriate data.
        /// </summary>
        private void SavePillSelectionsBeforeNavigation()
        {
            try
            {
                // Check if current view is AssumptionsVM and save its data
                if (CurrentStepViewModel is TestCaseGenerator_AssumptionsVM assumptionsVm)
                {
                    assumptionsVm.SaveAllAssumptionsData();
                    TestCaseEditorApp.Services.Logging.Log.Debug("[Navigation] Saved assumptions data before navigation");
                }
                // Check if current view is QuestionsVM and save its data
                else if (CurrentStepViewModel is TestCaseGenerator_QuestionsVM questionsVm)
                {
                    questionsVm.SaveQuestionsForRequirement(CurrentRequirement, markDirty: false);
                    TestCaseEditorApp.Services.Logging.Log.Debug("[Navigation] Saved questions data before navigation");
                }
                // Check if current view is HeaderVM and save its data
                else if (CurrentStepViewModel is TestCaseGenerator_HeaderVM headerVm)
                {
                    // Header data saves automatically via requirement property binding
                    TestCaseEditorApp.Services.Logging.Log.Debug("[Navigation] Header data handled by requirement property");
                }
            }
            catch (Exception ex)
            {
                TestCaseEditorApp.Services.Logging.Log.Debug($"[Navigation] Error saving data: {ex.Message}");
            }
        }



        private void ForwardRequirementToActiveHeader(Requirement? req)
        {
            TestCaseEditorApp.Services.Logging.Log.Debug($"[ForwardReq] invoked ActiveHeader={ActiveHeader?.GetType().Name ?? "<null>"} ReqItem={req?.Item ?? "<null>"} Method='{req?.Method}' DescLen={(req?.Description?.Length ?? 0)}");

            if (req == null)
            {
                // Clear both headers defensively when no requirement
                try
                {
                    if (_testCaseGeneratorHeader != null)
                    {
                        _testCaseGeneratorHeader.RequirementDescription = string.Empty;
                        _testCaseGeneratorHeader.RequirementMethod = string.Empty;
                    }
                }
                catch { }

                try
                {
                    if (_workspaceHeaderViewModel != null)
                        _workspaceHeaderViewModel.CurrentRequirementSummary = string.Empty;
                }
                catch { }

                return;
            }

            var description = req.Description ?? string.Empty;
            var methodStr = req.Method.ToString();

            // 1) Update the test-case header instance if it exists (always, regardless of ActiveHeader)
            try
            {
                if (_testCaseGeneratorHeader != null)
                {
                    _testCaseGeneratorHeader.RequirementDescription = description;
                    _testCaseGeneratorHeader.RequirementMethod = methodStr;
                    _testCaseGeneratorHeader.RequirementMethodEnum = req.Method;
                    _testCaseGeneratorHeader.CurrentRequirementName = req.Name ?? req.Item ?? string.Empty;
                    _testCaseGeneratorHeader.CurrentRequirementSummary = ShortSummary(req.Description);
                    TestCaseEditorApp.Services.Logging.Log.Debug($"[ForwardReq] wrote to _testCaseGeneratorHeader: Method='{methodStr}'");
                }
            }
            catch (Exception ex)
            {
                TestCaseEditorApp.Services.Logging.Log.Debug($"[ForwardReq] failed writing to _testCaseGeneratorHeader: {ex.Message}");
            }

            // 2) Update the workspace header instance if it exists
            try
            {
                if (_workspaceHeaderViewModel != null)
                {
                    _workspaceHeaderViewModel.CurrentRequirementTitle = req.Name ?? string.Empty;
                    _workspaceHeaderViewModel.CurrentRequirementSummary = ShortSummary(req.Description);
                    _workspaceHeaderViewModel.CurrentRequirementId = req.Item ?? string.Empty;
                    _workspaceHeaderViewModel.CurrentRequirementStatus = req.Status ?? string.Empty;
                    TestCaseEditorApp.Services.Logging.Log.Debug("[ForwardReq] wrote to _workspaceHeaderViewModel");
                }
            }
            catch (Exception ex)
            {
                TestCaseEditorApp.Services.Logging.Log.Debug($"[ForwardReq] failed writing to _workspaceHeaderViewModel: {ex.Message}");
            }

            // 3) Best-effort: set properties on the ActiveHeader object if it's some other header type
            try
            {
                var header = ActiveHeader;
                if (header != null && header != _testCaseGeneratorHeader && header != _workspaceHeaderViewModel)
                {
                    var t = header.GetType();
                    void TrySet(string propName, object? val)
                    {
                        var prop = t.GetProperty(propName, BindingFlags.Public | BindingFlags.Instance);
                        if (prop != null && prop.CanWrite) prop.SetValue(header, val);
                    }

                    TrySet("RequirementDescription", description);
                    TrySet("RequirementMethod", methodStr);
                    TrySet("RequirementMethodEnum", req.Method);
                    TrySet("CurrentRequirementName", req.Name ?? string.Empty);
                    TrySet("CurrentRequirementSummary", ShortSummary(req.Description));
                    TestCaseEditorApp.Services.Logging.Log.Debug("[ForwardReq] wrote to ActiveHeader via reflection");
                }
            }
            catch (Exception ex)
            {
                TestCaseEditorApp.Services.Logging.Log.Debug($"[ForwardReq] reflection fallback failed: {ex.Message}");
            }
        }

        private void UpdateTestCaseStepSelectability()
        {
            var testCaseStep = TestCaseGeneratorSteps?.FirstOrDefault(s => s.Id == "testcase-creation");
            if (testCaseStep != null)
            {
                var hasTestCases = CurrentRequirement?.GeneratedTestCases?.Count > 0 || CurrentRequirement?.HasGeneratedTestCase == true;
                TestCaseEditorApp.Services.Logging.Log.Info($"[MainViewModel] UpdateTestCaseStepSelectability: Current={testCaseStep.IsSelectable}, New={hasTestCases}, GeneratedTestCases.Count={CurrentRequirement?.GeneratedTestCases?.Count ?? 0}, HasGeneratedTestCase={CurrentRequirement?.HasGeneratedTestCase}");
                
                if (testCaseStep.IsSelectable != hasTestCases)
                {
                    testCaseStep.IsSelectable = hasTestCases;
                    TestCaseEditorApp.Services.Logging.Log.Info($"[MainViewModel] Test Cases step IsSelectable changed to {hasTestCases} for requirement {CurrentRequirement?.Item}");
                    
                    // Force property change notifications
                    OnPropertyChanged(nameof(TestCaseGeneratorSteps));
                }
                else
                {
                    TestCaseEditorApp.Services.Logging.Log.Info($"[MainViewModel] Test Cases step IsSelectable already {hasTestCases}, no change needed");
                }
            }
            else
            {
                TestCaseEditorApp.Services.Logging.Log.Info($"[MainViewModel] Test Cases step not found in TestCaseGeneratorSteps");
            }
        }

        private void CurrentRequirement_PropertyChanged(object? sender, PropertyChangedEventArgs e)
        {
            // Update test case step selectability for any property change that might affect test cases
            UpdateTestCaseStepSelectability();
            
            if (string.IsNullOrEmpty(e?.PropertyName) ||
                e.PropertyName == nameof(Requirement.Description) ||
                e.PropertyName == nameof(Requirement.Method) ||
                e.PropertyName == nameof(Requirement.GeneratedTestCases))
            {
                try
                {
                    if (Application.Current?.Dispatcher?.CheckAccess() == true)
                    {
                        ForwardRequirementToActiveHeader(CurrentRequirement);
                    }
                    else
                    {
                        Application.Current?.Dispatcher?.Invoke(() => ForwardRequirementToActiveHeader(CurrentRequirement));
                    }
                }
                catch
                {
                    // best-effort - swallow exceptions
                }
            }
        }

        // -----------------
        // Import implementation (now delegated to RequirementImportExportViewModel)
        // -----------------
        // TODO: EXTRACT TO RequirementImportExportViewModel - massive 350+ line method delegation COMPLETED
        private async Task ImportFromPathAsync(string path, bool replace)
        {
            if (_requirementImportExport != null)
            {
                await _requirementImportExport.ImportFromPathAsync(path, replace);
            }
        }

        // Helper methods exposed for delegation
        public void SaveSessionAuto()
        {
            try
            {
                if (!string.IsNullOrWhiteSpace(WorkspacePath) && WorkspaceService != null && CurrentWorkspace != null)
                    TestCaseEditorApp.Services.WorkspaceFileManager.Save(WorkspacePath!, CurrentWorkspace);
            }
            catch (Exception ex) { _logger?.LogDebug(ex, "[SaveSessionAuto] failed"); }
        }

        public void RefreshSupportingInfo()
        {
            if (CurrentRequirement != null) BuildSupportingInfoFromRequirement(CurrentRequirement);
        }

        public void ComputeDraftedCount() { /* app-specific */ }
        public void RaiseCounterChanges() { /* app-specific */ }

        public async Task BatchAnalyzeRequirementsAsync(List<Requirement> requirements)
        {
            if (_requirementAnalysis != null)
            {
                await _requirementAnalysis.BatchAnalyzeRequirementsAsync(requirements);
            }
        }

        // [DUPLICATE REMOVED] - RequirementsOnCollectionChanged, RefreshSupportingInfo, ComputeDraftedCount already exist

        private void InitializeAutoSave()
        {
            try
            {
                _autoSaveService = new TestCaseEditorApp.Services.AutoSaveService(
                    TimeSpan.FromMinutes(AutoSaveIntervalMinutes),
                    () => IsDirty && !string.IsNullOrWhiteSpace(WorkspacePath) && CurrentWorkspace != null,
                    () => { SaveWorkspace(); },
                    (msg, secs) => SetTransientStatus(msg, secs)
                );
                _autoSaveService.Start();
                TestCaseEditorApp.Services.Logging.Log.Debug($"[AutoSave] Service initialized ({AutoSaveIntervalMinutes} minute interval)");
            }
            catch (Exception ex)
            {
                TestCaseEditorApp.Services.Logging.Log.Debug($"[AutoSave] Initialization failed: {ex.Message}");
            }
        }

        // Helper properties / methods
        private IPersistenceService WorkspaceService => _persistence;

        // [DUPLICATE REMOVED] - SaveSessionAuto already exists

        // Diagnostic helper: probe post-save artifacts so we can tell whether the
        // workspace file, meta file, marker file, audit logs or temp copies exist
        // immediately after a save completes.
        private void LogPostSaveDiagnostics(string path)
        {
            try
            {
                TestCaseEditorApp.Services.SaveDiagnostics.Probe(path);
            }
            catch (Exception ex)
            {
                TestCaseEditorApp.Services.Logging.Log.Debug($"[PostSave] Probe delegation failed: {ex.Message}");
            }
        }

        // [DUPLICATE REMOVED] - RefreshSupportingInfo already exists

        private void BuildSupportingInfoFromRequirement(Requirement req)
        {
            LooseTables.Clear();
            LooseParagraphs.Clear();

            try
            {
                if (req?.LooseContent?.Paragraphs != null)
                {
                    foreach (var p in req.LooseContent.Paragraphs) LooseParagraphs.Add(p);
                }

                if (req?.LooseContent?.Tables != null)
                {
                    foreach (var t in req.LooseContent.Tables)
                    {
                        var vm = new LooseTableViewModel { Title = t.EditableTitle };
                        LooseTables.Add(vm);
                    }
                }
            }
            catch (Exception ex) { _logger?.LogDebug(ex, "[BuildSupportingInfoFromRequirement] failed"); }
        }

        // [DUPLICATE REMOVED] - ComputeDraftedCount and RaiseCounterChanges already exist
        private void WireGeneratorCallbacks() { /* wire generator events if needed */ }

        private string? FormatSupportingNotes(Requirement req) => req?.Description;
        private IEnumerable<TableDto>? FormatSupportingTables(Requirement req) => Enumerable.Empty<TableDto>();
        private string GetLatestLlmDraftText(Requirement req) => string.Empty;
        private string BuildStrictOutputFromSaved(Requirement req) => string.Empty;

        // Map simple Status property to StatusMessage
        public string? Status
        {
            get => StatusMessage;
            set
            {
                if (StatusMessage == value) return;
                StatusMessage = value;
                OnPropertyChanged(nameof(Status));
                OnPropertyChanged(nameof(StatusMessage));
            }
        }

        private static string ShortSummary(string? description, int maxLength = 200)
        {
            if (string.IsNullOrWhiteSpace(description)) return string.Empty;
            var firstLine = description.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries)
                                       .FirstOrDefault() ?? description;
            firstLine = firstLine.Trim();
            if (firstLine.Length <= maxLength) return firstLine;
            return firstLine.Substring(0, maxLength).Trim() + "ï¿½";
        }

        /// <summary>
        /// Sets a transient status message that appears temporarily in the UI.
        /// Uses the ToastNotificationService for user notifications.
        /// </summary>
        /// <param name="message">Message to display</param>
        /// <param name="durationSeconds">Duration in seconds (default 3)</param>
        /// <param name="blockingError">If true, shows as blocking error dialog</param>
        internal void SetTransientStatus(string message, int durationSeconds = 3, bool blockingError = false)
        {
            try
            {
                TestCaseEditorApp.Services.TransientStatus.Show(_toastService, message, durationSeconds, blockingError);
            }
            catch (Exception ex)
            {
                _logger?.LogWarning(ex, "Failed to set transient status: {Message}", message);
            }
        }

        /// <summary>
        /// Batch analyze requirements in background after import.
        /// Shows progress notifications and updates requirements with analysis results.
        /// Thread-safe with duplicate prevention.
        /// </summary>
        // TODO: EXTRACT TO RequirementAnalysisViewModel - massive method delegation
        // [DUPLICATE REMOVED] - BatchAnalyzeRequirementsAsync already exists

        /// <summary>
        // TODO: Extract to RequirementImportExportViewModel - method moved for Round 6

        // TODO: Extract to RequirementImportExportViewModel - method moved for Round 6

        // TODO: Extract to RequirementAnalysisViewModel - method moved for Round 3 testing

        // TODO: Extract to RequirementAnalysisViewModel - method moved for domain completion

        // TODO: Extract to RequirementAnalysisViewModel - method moved for domain completion

        // TODO: Extract to RequirementAnalysisViewModel - method moved for domain completion

        // TODO: Extract to RequirementImportExportViewModel - method moved for Round 6

        // TODO: Extract to RequirementImportExportViewModel - method moved for Round 6

        // TODO: Extract to RequirementGenerationViewModel - method moved for Round 5

        // TODO: Extract to RequirementGenerationViewModel - method moved for Round 5

        // TODO: Extract to RequirementGenerationViewModel - method moved for Round 5

        /// <summary>
        /// Sets up integrated LLM workspace for streamlined communication with standardized formats.
        /// </summary>
        // TODO: EXTRACT TO LLMServiceManagementViewModel - delegation method
        private void SetupLlmWorkspace()
        {
            _llmServiceManagement?.SetupLlmWorkspace();
        }

        /// <summary>
        /// Pastes ChatGPT analysis from clipboard and applies it to current requirements.
        /// </summary>
        private void PasteChatGptAnalysis()
        {
            _requirementAnalysis?.PasteChatGptAnalysis();
        }
        
        /// <summary>
        /// Saves the current project state.
        /// </summary>
        private async void SaveProject()
        {
            if (_workspaceManagementMediator != null)
            {
                await _workspaceManagementMediator.SaveProjectAsync();
            }
        }

        /// <summary>
        /// Closes the current project.
        /// </summary>
        private async void CloseProject()
        {
            if (_workspaceManagementMediator != null)
            {
                await _workspaceManagementMediator.CloseProjectAsync();
            }
        }
        
        public void RefreshCommandStates()
        {
            try
            {
                // Refresh command states that depend on project state
                ((RelayCommand?)ExportForChatGptCommand)?.NotifyCanExecuteChanged();
                ((RelayCommand?)GenerateAnalysisCommandCommand)?.NotifyCanExecuteChanged();
                ((RelayCommand?)GenerateTestCaseCommandCommand)?.NotifyCanExecuteChanged();
                ((RelayCommand?)AnalyzeRequirementsCommand)?.NotifyCanExecuteChanged();
                ((RelayCommand?)BatchAnalyzeCommand)?.NotifyCanExecuteChanged();
                ((RelayCommand?)SaveWorkspaceCommand)?.NotifyCanExecuteChanged();
            }
            catch (Exception ex)
            {
                TestCaseEditorApp.Services.Logging.Log.Error(ex, "[PROJECT] Error refreshing command states during close");
            }
        }

        // Dispose/unsubscribe
        public void Dispose()
        {
            try { if (Requirements != null) Requirements.CollectionChanged -= RequirementsOnCollectionChanged; } catch { }
            try { UnhookOldRequirement(); } catch { }
            try { if (_statusTimer != null) { _statusTimer.Stop(); _statusTimer = null; } } catch { }
            try { if (_autoSaveService != null) { _autoSaveService.Stop(); _autoSaveService = null; } } catch { }
            try { if (_requirementsNavigator is IDisposable d) d.Dispose(); } catch { }
            try { if (HeaderViewModel is IDisposable hd) hd.Dispose(); } catch { }
            try { UnwireHeaderSubscriptions(); } catch { }

            try
            {
                AnythingLLMMediator.StatusUpdated -= OnAnythingLLMStatusFromMediator;
            }
            catch { }

            try
            {
                _llmProbeService?.Stop();
                _llmProbeService?.Dispose();
            }
            catch { }
            _llmProbeService = null;
        }

        // -------------------------
        // Modal overlay system
        // -------------------------
        
        /// <summary>
        /// Show a modal dialog with the specified content and title
        /// </summary>
        // TODO: EXTRACT TO UIModalManagementViewModel - delegation method
        public void ShowModal(object viewModel, string title = "Modal Dialog")
        {
            _uiModalManagement?.ShowModal(viewModel, title);
        }

        /// <summary>
        /// Close the current modal dialog
        /// </summary>
        // TODO: EXTRACT TO UIModalManagementViewModel - delegation method
        public void CloseModal()
        {
            _uiModalManagement?.CloseModal();
        }

        /// <summary>
        /// Check if a modal dialog is currently shown
        /// </summary>
        // TODO: EXTRACT TO UIModalManagementViewModel - property delegation
        public bool IsModalOpen => _uiModalManagement?.IsModalVisible ?? false;

        /// <summary>
        /// Show the API key configuration modal
        /// </summary>
        public void ShowApiKeyConfigModal()
        {
            _uiModalManagement?.ShowApiKeyConfigModal();
        }

        /// <summary>
        /// Show the workspace selection modal for creating a new project
        /// </summary>
        public void ShowWorkspaceSelectionModal()
        {
            _logger?.LogInformation("[DEBUG] ShowWorkspaceSelectionModal called, uiModalManagement: {HasUI}", _uiModalManagement != null);
            _uiModalManagement?.ShowWorkspaceSelectionModal();
        }

        /// <summary>
        /// Show the workspace selection modal for opening an existing project
        /// </summary>
        public void ShowWorkspaceSelectionModalForOpen()
        {
            _logger?.LogInformation("[DEBUG] ShowWorkspaceSelectionModalForOpen called, uiModalManagement: {HasUI}", _uiModalManagement != null);
            _uiModalManagement?.ShowWorkspaceSelectionModalForOpen();
        }

        /// <summary>
        /// Show the import workflow modal for step-by-step import configuration
        /// </summary>
        public void ShowImportWorkflow()
        {
            _uiModalManagement?.ShowImportWorkflow();
        }

        public void OnImportWorkflowCompleted(object? sender, ImportWorkflowCompletedEventArgs e)
        {
            CloseModal();
            
            // Configure settings based on user choices
            AutoAnalyzeOnImport = e.AutoAnalyzeRequirements;
            AutoExportForChatGpt = e.ExportForChatGpt;
            
            // TODO: Implement the actual import with the configured settings
            // This should use the document path and workspace save path from the args
            SetTransientStatus($"Import workflow completed. Document: {e.DocumentPath}, Workspace: {e.WorkspaceName}", 3);
        }

        public void OnImportWorkflowCancelled(object? sender, EventArgs e)
        {
            CloseModal();
            SetTransientStatus("Import workflow cancelled.", 2);
        }

        private async void OnImportRequirementsWorkflowCompleted(object? sender, RequirementsImportCompletedEventArgs e)
        {
            try
            {
                // Configure settings based on user choices
                AutoAnalyzeOnImport = e.AutoAnalyzeEnabled;
                AutoExportForChatGpt = e.AutoExportEnabled;

                // Set workspace path for saving later
                WorkspacePath = e.WorkspaceSavePath;

                // Import the requirements from the document
                if (e.DocumentPath.EndsWith(".docx", StringComparison.OrdinalIgnoreCase))
                {
                    await ImportFromPathAsync(e.DocumentPath, replace: true);
                }
                else
                {
                    SetTransientStatus("Unsupported file format. Please select a .docx file.", blockingError: true);
                    return;
                }

                // Navigate back to Requirements view after import
                SelectedMenuSection = "TestCase";
                
                SetTransientStatus($"Successfully imported requirements from {Path.GetFileName(e.DocumentPath)}. Workspace saved as {Path.GetFileName(e.WorkspaceSavePath)}.", 5);
            }
            catch (Exception ex)
            {
                _logger?.LogError(ex, "Failed to complete import workflow");
                SetTransientStatus($"Failed to import requirements: {ex.Message}", blockingError: true);
            }
        }

        private void OnImportRequirementsWorkflowCancelled(object? sender, EventArgs e)
        {
            // Navigate back to previous section (typically TestCase)
            SelectedMenuSection = "TestCase";
            SetTransientStatus("Import workflow cancelled.", 2);
        }
        public void ShowRequirementDescriptionEditorModal(Requirement requirement)
        {
            _uiModalManagement?.ShowRequirementDescriptionEditorModal(requirement);
        }

        /// <summary>
        /// Implementation of ITestCaseGenerator_Navigator.ShowRequirementEditor
        /// </summary>
        public void ShowRequirementEditor(Requirement requirement)
        {
            try
            {
                TestCaseEditorApp.Services.Logging.Log.Debug($"[MainViewModel] ShowRequirementEditor called for {requirement?.Item}");
                
                if (requirement == null)
                {
                    TestCaseEditorApp.Services.Logging.Log.Warn("[MainViewModel] ShowRequirementEditor called with null requirement");
                    return;
                }
                
                ShowRequirementDescriptionEditorModal(requirement);
                TestCaseEditorApp.Services.Logging.Log.Debug("[MainViewModel] ShowRequirementDescriptionEditorModal completed");
            }
            catch (Exception ex)
            {
                TestCaseEditorApp.Services.Logging.Log.Error(ex, "[MainViewModel] Error in ShowRequirementEditor");
                _notificationService?.ShowError($"Failed to open requirement editor: {ex.Message}");
            }
        }

        /// <summary>
        /// Handle SelectedStep property changes (extracted for readability)
        /// </summary>
        private void HandleSelectedStepChange(StepDescriptor? value)
        {
            // Save BEFORE changing SelectedStep so CurrentStepViewModel still points to the old view
            if (_hasUnsavedChanges)
            {
                SavePillSelectionsBeforeNavigation();
            }

            if (!SetProperty(ref _selectedStep, value)) return;

            _logger?.LogDebug("SelectedStep set: {Step}", value?.DisplayName);

            // Collapse any file menus when switching steps
            foreach (var step in TestCaseGeneratorSteps)
            {
                if (step != value && step.IsFileMenuExpanded)
                {
                    step.IsFileMenuExpanded = false;
                }
            }

            if (value?.CreateViewModel == null)
            {
                CurrentStepViewModel = InitialStateViewModel;
                return;
            }

            try
            {
                // Save assumptions from previous view BEFORE switching
                if (CurrentStepViewModel is TestCaseGenerator_AssumptionsVM previousAssumptionsVm)
                {
                    previousAssumptionsVm.SaveAllAssumptionsData();
                    TestCaseEditorApp.Services.Logging.Log.Debug("[SelectedStep] Saved assumptions before switching view");
                }
                
                var created = value.CreateViewModel(_services);
                CurrentStepViewModel = created;

                // Set current requirement on AssumptionsVM when view is created
                if (created is TestCaseGenerator_AssumptionsVM assumptionsVm)
                {
                    assumptionsVm.SetCurrentRequirement(CurrentRequirement);
                    assumptionsVm.LoadPillsForRequirement(CurrentRequirement);
                }

                if (created is TestCaseGenerator_VM reqVm)
                {
                    reqVm.TestCaseGenerator = _testCaseGenerator;
                }
            }
            catch (Exception ex)
            {
                _logger?.LogWarning(ex, "CreateViewModel failed for step {Step}", value?.Id);
                CurrentStepViewModel = InitialStateViewModel;
            }
        }

        /// <summary>
        /// Show the split text editor modal
        /// </summary>
        public void ShowSplitTextEditorModal(string text)
        {
            _uiModalManagement?.ShowSplitTextEditorModal(text);
        }

        /// <summary>
        /// Show the import method selection modal
        /// </summary>
        public Task<ImportMethod> ShowImportMethodSelectionModalAsync()
        {
            var tcs = new TaskCompletionSource<ImportMethod>();
            
            _importMethodViewModel = new ImportMethodSelectionViewModel();
            _importMethodViewModel.ImportMethodSelected += (sender, e) =>
            {
                CloseModal();
                
                // Handle ImportWorkflow by navigating to Import section
                if (e.Method == ImportMethod.ImportWorkflow)
                {
                    SelectedMenuSection = "Import";
                    tcs.SetResult(ImportMethod.ImportWorkflow);
                }
                else
                {
                    tcs.SetResult(e.Method);
                }
            };
            
            ShowModal(_importMethodViewModel, "Import Method");
            return tcs.Task;
        }



        public async void OnWorkspaceSelected(object? sender, WorkspaceSelectedEventArgs e)
        {
            CloseModal();
            
            TestCaseEditorApp.Services.Logging.Log.Info($"[OnWorkspaceSelected] Workspace selected: {e.WorkspaceName}, WasCreated: {e.WasCreated}");
            
            try
            {
                // Find the actual workspace object from the AnythingLLM service
                TestCaseEditorApp.Services.Logging.Log.Info($"[OnWorkspaceSelected] Getting workspaces from AnythingLLM service...");
                var workspaces = await _anythingLLMService.GetWorkspacesAsync().ConfigureAwait(false);
                var workspace = workspaces?.FirstOrDefault(w => w.Name.Equals(e.WorkspaceName, StringComparison.OrdinalIgnoreCase));
                
                if (workspace == null)
                {
                    TestCaseEditorApp.Services.Logging.Log.Info($"[OnWorkspaceSelected] Could not find workspace: {e.WorkspaceName}");
                    // Use Dispatcher to show error on UI thread
                    Application.Current.Dispatcher.Invoke(() => 
                    {
                        _notificationService.ShowError($"Could not find workspace: {e.WorkspaceName}");
                    });
                    return;
                }
                
                TestCaseEditorApp.Services.Logging.Log.Info($"[OnWorkspaceSelected] Found workspace: {workspace.Name} (Slug: {workspace.Slug}), HasLocalFile: {workspace.HasLocalFile}, LocalFilePath: {workspace.LocalFilePath}");
                
                // Use Dispatcher for UI operations
                await Application.Current.Dispatcher.InvokeAsync(() =>
                {
                    // Set workspace slug but don't clear requirements yet - LoadWorkspaceFromPath will handle that
                    CurrentAnythingLLMWorkspaceSlug = workspace.Slug;
                    
                    // Don't change the selected step - keep current selection (e.g., Project menu)
                });
                
                if (e.WasCreated)
                {
                    // New workspace was created - show import options using custom modal
                    var importMethod = await ShowImportMethodSelectionModalAsync();
                        
                    // Execute commands on UI thread
                    await Application.Current.Dispatcher.InvokeAsync(() =>
                    {
                        switch (importMethod)
                        {
                            case ImportMethod.Word: // Word with analysis
                                AutoAnalyzeOnImport = true;
                                ImportWordCommand?.Execute(null);
                                break;
                            case ImportMethod.WordNoAnalysis: // Word without analysis
                                AutoAnalyzeOnImport = false;
                                ImportWordCommand?.Execute(null);
                                break;
                            case ImportMethod.ImportWorkflow: // Full workflow
                                CloseModal(); // Close the import method selection first
                                ShowImportWorkflow();
                                break;
                            case ImportMethod.Quick: // Quick
                                QuickImportCommand?.Execute(null);
                                break;
                            case ImportMethod.Skip: // Skip or cancelled
                                break;
                        }
                        
                        SetTransientStatus($"ðŸ†• Created and opened project: {workspace.Name}", 4);
                    });
                    
                    TestCaseEditorApp.Services.Logging.Log.Info($"[PROJECT] Created new project with workspace slug '{workspace.Slug}'");
                }
                else
                {
                    TestCaseEditorApp.Services.Logging.Log.Info($"[OnWorkspaceSelected] Existing workspace selected");
                    // Existing workspace was selected - run UI operations on UI thread
                    await Application.Current.Dispatcher.InvokeAsync(() =>
                    {
                        SetTransientStatus($"ðŸ“‚ Opened existing project: {workspace.Name}", 4);
                    });
                    
                    TestCaseEditorApp.Services.Logging.Log.Info($"[PROJECT] Opened existing project with workspace slug '{workspace.Slug}'");
                    
                    // Automatically load local workspace file if it exists
                    if (workspace.HasLocalFile && !string.IsNullOrEmpty(workspace.LocalFilePath))
                    {
                        TestCaseEditorApp.Services.Logging.Log.Info($"[OnWorkspaceSelected] Loading local workspace file: {workspace.LocalFilePath}");
                        await Application.Current.Dispatcher.InvokeAsync(() =>
                        {
                            LoadWorkspaceFromPath(workspace.LocalFilePath);
                        });
                    }
                    else
                    {
                        TestCaseEditorApp.Services.Logging.Log.Warn($"[OnWorkspaceSelected] No local file found for workspace. HasLocalFile: {workspace.HasLocalFile}, LocalFilePath: '{workspace.LocalFilePath}'");
                    }
                }
            }
            catch (Exception ex)
            {
                TestCaseEditorApp.Services.Logging.Log.Error(ex, "[PROJECT] Error handling workspace selection");
                
                // Show error on UI thread
                await Application.Current.Dispatcher.InvokeAsync(() =>
                {
                    _notificationService.ShowError($"Error opening project: {ex.Message}");
                    SetTransientStatus("âŒ Failed to open project", 3);
                });
            }
        }



        public void OnRequirementEdited(object? sender, RequirementEditedEventArgs e)
        {
            CloseModal();
            _notificationService.ShowSuccess("Requirement updated successfully");
            
            // Refresh any dependent views if needed
            // The requirement is already updated since it's passed by reference
        }

        public void OnRequirementAnalysisRequested(object? sender, RequirementAnalysisRequestedEventArgs e)
        {
            // Close the editor modal first
            CloseModal();
            
            // Request analysis from the analysis service
            // This would typically be handled by the TestCaseGenerator_AnalysisVM
            _notificationService.ShowInfo("Analysis requested - please use the main analysis panel");
        }





        private async void OnNewProjectCreated(object? sender, NewProjectCompletedEventArgs e)
        {
            try
            {
                TestCaseEditorApp.Services.Logging.Log.Info($"[PROJECT] Starting project creation. WorkspaceName: {e.WorkspaceName}, DocumentPath: {e.DocumentPath}");
                
                // Configure settings based on user choices
                AutoExportForChatGpt = e.AutoExportEnabled;
                
                TestCaseEditorApp.Services.Logging.Log.Info($"[PROJECT] Settings configured - AutoExport: {AutoExportForChatGpt}");

                // Set workspace path BEFORE importing to avoid dialog
                WorkspacePath = e.ProjectSavePath;
                TestCaseEditorApp.Services.Logging.Log.Info($"[PROJECT] Workspace path set to: {WorkspacePath}");

                // Import requirements from the selected document
                TestCaseEditorApp.Services.Logging.Log.Info($"[PROJECT] Importing requirements from: {e.DocumentPath}");
                await ImportFromPathAsync(e.DocumentPath, replace: true);

                // Save project using the existing path (no dialog)
                TestCaseEditorApp.Services.Logging.Log.Info($"[PROJECT] Saving project to: {WorkspacePath}");
                SaveWorkspace(); // Use SaveWorkspace() instead of SaveWorkspaceAsync() to avoid dialog

                // Switch to main workspace view
                SelectedMenuSection = "Requirements";
                
                TestCaseEditorApp.Services.Logging.Log.Info($"[PROJECT] Project creation completed successfully");
                _notificationService.ShowSuccess($"Project '{e.ProjectName}' created successfully with {Requirements?.Count ?? 0} requirements!");
            }
            catch (Exception ex)
            {
                TestCaseEditorApp.Services.Logging.Log.Error(ex, "[PROJECT] Error completing new project creation");
                _notificationService.ShowError($"Error creating project: {ex.Message}");
            }
        }

        /// <summary>
        /// Subscribe to WorkspaceManagement domain events for UI coordination
        /// </summary>
        private void SubscribeToWorkspaceManagementEvents()
        {
            if (_workspaceManagementMediator == null) return;

            // Subscribe to project lifecycle events
            _workspaceManagementMediator.Subscribe<WorkspaceManagementEvents.ProjectOpened>(OnProjectOpened);
            _workspaceManagementMediator.Subscribe<WorkspaceManagementEvents.ProjectClosed>(OnProjectClosed);
            _workspaceManagementMediator.Subscribe<WorkspaceManagementEvents.ProjectSaved>(OnProjectSaved);
            
            // Subscribe to workspace selection events to handle modal requests
            _workspaceManagementMediator.Subscribe<WorkspaceManagementEvents.WorkspaceSelectionRequested>(OnWorkspaceSelectionRequested);
        }

        /// <summary>
        /// Handle project opened event
        /// </summary>
        private void OnProjectOpened(WorkspaceManagementEvents.ProjectOpened e)
        {
            CurrentAnythingLLMWorkspaceSlug = e.AnythingLLMWorkspaceSlug;
            WorkspacePath = e.WorkspacePath;
            CurrentWorkspace = e.Workspace;
            
            SetTransientStatus($"✅ Project '{e.WorkspaceName}' opened", 3);
            _logger?.LogInformation("Project opened: {WorkspaceName}", e.WorkspaceName);
        }

        /// <summary>
        /// Handle project closed event
        /// </summary>
        private void OnProjectClosed(WorkspaceManagementEvents.ProjectClosed e)
        {
            CurrentAnythingLLMWorkspaceSlug = null;
            WorkspacePath = null;
            CurrentWorkspace = null;
            
            SetTransientStatus("Project closed", 2);
            _logger?.LogInformation("Project closed: {WorkspacePath}", e.WorkspacePath);
        }

        /// <summary>
        /// Handle project saved event
        /// </summary>
        private void OnProjectSaved(WorkspaceManagementEvents.ProjectSaved e)
        {
            SetTransientStatus("💾 Project saved", 2);
            _logger?.LogInformation("Project saved: {WorkspacePath}", e.WorkspacePath);
        }

        /// <summary>
        /// Handle workspace selection requests by showing the appropriate modal
        /// </summary>
        private void OnWorkspaceSelectionRequested(WorkspaceManagementEvents.WorkspaceSelectionRequested e)
        {
            _logger?.LogInformation("[DEBUG] OnWorkspaceSelectionRequested called, IsOpenExisting: {IsOpenExisting}", e.IsOpenExisting);
            if (e.IsOpenExisting)
            {
                _logger?.LogInformation("[DEBUG] Calling ShowWorkspaceSelectionModalForOpen");
                ShowWorkspaceSelectionModalForOpen();
            }
            else
            {
                _logger?.LogInformation("[DEBUG] Calling ShowWorkspaceSelectionModal");
                ShowWorkspaceSelectionModal();
            }
        }

        private void OnNewProjectCancelled(object? sender, EventArgs e)
        {
            // TODO: Handle project cancellation through domain events if needed
            _logger?.LogInformation("New project creation cancelled");
        }

        // === WORKSPACE ACCESS PROPERTIES ===
        // Provide access to workspace state for remaining legacy code
        public Workspace? CurrentWorkspace { get; set; }
        public Workspace? Workspace
        {
            get => CurrentWorkspace;
            set => CurrentWorkspace = value;
        }
    }
}
