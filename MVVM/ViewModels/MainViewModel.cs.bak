using System;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Diagnostics;
using System.Windows;
using System.Windows.Input;
using System.Windows.Threading;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using Microsoft.Win32;
using TestCaseEditorApp.MVVM.Models;
using TestCaseEditorApp.Helpers;
using TestCaseEditorApp.Services;
using Microsoft.Extensions.Logging;

// alias used in other code
using VMVerMethod = TestCaseEditorApp.MVVM.Models.VerificationMethod;
using System.Collections.Specialized;
using System.Reflection;
using System.Text;

namespace TestCaseEditorApp.MVVM.ViewModels
{
    /// <summary>
    /// Consolidated MainViewModel — single file containing selection/header state,
    /// workspace state, import/save logic and helpers. Designed to compile without
    /// relying on additional partial helper files.
    /// 
    /// Notes:
    /// - Uses CommunityToolkit.Mvvm [ObservableProperty] to generate properties.
    /// - Provides explicit ICommand properties for navigation so IRequirementsNavigator is satisfied.
    /// - Includes minimal no-op stubs internally for design-time; remove them if you have external stubs to avoid duplicate types.
    /// </summary>
    public partial class MainViewModel : ObservableObject, IDisposable, IRequirementsNavigator
    {
        // --- Services / collaborators ---
        private IRequirementService _requirementService;
        private IPersistenceService _persistence;
        private IFileDialogService _fileDialog;
        private IServiceProvider _services;

        // --- Header / view state ---
        private WorkspaceHeaderViewModel _workspaceHeaderViewModel = new WorkspaceHeaderViewModel();
        public WorkspaceHeaderViewModel HeaderViewModel { get; private set; }
        public NavigationViewModel Navigation { get; set; } = new NavigationViewModel();

        // --- Logging ---
        private readonly ILogger<MainViewModel>? _logger;

        // --- Observable properties (CommunityToolkit source-gen) ---
        [ObservableProperty] private ObservableCollection<Requirement> requirements = new();
        [ObservableProperty] private Requirement? currentRequirement;
        [ObservableProperty] private string? workspacePath;
        [ObservableProperty] private bool hasUnsavedChanges;
        [ObservableProperty] private string? statusMessage;

        [ObservableProperty] private string? wordFilePath;
        [ObservableProperty] private string? currentSourcePath;

        [ObservableProperty] private ObservableCollection<LooseTableViewModel> looseTables = new();
        [ObservableProperty] private ObservableCollection<string> looseParagraphs = new();

        // Other state and helpers
        private object? _currentStepViewModel;
        public object? CurrentStepViewModel
        {
            get => _currentStepViewModel;
            set => SetProperty(ref _currentStepViewModel, value);
        }

        private bool _wrapOnNextWithoutTestCase;
        public bool WrapOnNextWithoutTestCase
        {
            get => _wrapOnNextWithoutTestCase;
            set => SetProperty(ref _wrapOnNextWithoutTestCase, value);
        }

        // Steps
        public ObservableCollection<StepDescriptor> TestCaseCreationSteps { get; } = new ObservableCollection<StepDescriptor>();

        // Navigator / supporting VMs
        private RequirementsIndexViewModel? _requirementsNavigator;
        public RequirementsIndexViewModel RequirementsNavigator => _requirementsNavigator!;

        // Misc
        private DispatcherTimer? _statusTimer;

        // Test case generator (minimal)
        private TestCaseGenViewModel? _testCaseGenerator = new TestCaseGenViewModel();

        // Header adapter for TestCaseCreator
        private TestCaseCreatorHeaderViewModel? _testCaseCreatorHeader;
        private bool _headerSubscriptionsWired = false;
        private INotifyPropertyChanged? _linkedTestCaseGeneratorInpc;

        // --- Constructors ---

        /// <summary>
        /// DI-friendly constructor. All parameters except loggers are required to provide real services.
        /// The logger parameters are optional (can be null) so existing manual instantiation remains safe.
        /// </summary>
        public MainViewModel(
            IRequirementService requirementService,
            IPersistenceService persistence,
            WorkspaceHeaderViewModel workspaceHeaderViewModel,
            NavigationViewModel navigationViewModel,
            IFileDialogService fileDialog,
            IServiceProvider? services = null,
            ILogger<MainViewModel>? logger = null,
            ILogger<RequirementsIndexViewModel>? requirementsIndexLogger = null)
        {
            // Ensure requirement service is valid
            if (requirementService == null) throw new ArgumentNullException(nameof(requirementService));
            _requirementService = requirementService;

            _persistence = persistence ?? throw new ArgumentNullException(nameof(persistence));
            _workspaceHeaderViewModel = workspaceHeaderViewModel ?? throw new ArgumentNullException(nameof(workspaceHeaderViewModel));
            Navigation = navigationViewModel ?? throw new ArgumentNullException(nameof(navigationViewModel));
            _fileDialog = fileDialog ?? throw new ArgumentNullException(nameof(fileDialog));
            _services = services ?? new SimpleServiceProviderStub();

            _logger = logger;

            HeaderViewModel = _workspaceHeaderViewModel;

            // wire collection change to keep counts/position updated
            Requirements.CollectionChanged += RequirementsOnCollectionChanged;

            // Create the navigator, pass child logger if available
            _requirementsNavigator = new RequirementsIndexViewModel(
                Requirements,
                () => CurrentRequirement,
                r => CurrentRequirement = r,
                () => CommitPendingEdits(),
                logger: requirementsIndexLogger);

            // Populate TestCaseCreationSteps
            TestCaseCreationSteps.Add(new StepDescriptor
            {
                Id = "requirements",
                DisplayName = "Requirements",
                Badge = "",
                CreateViewModel = svc =>
                {
                    var vm = new RequirementsViewModel(_persistence, this);
                    vm.TestCaseGenerator = _testCaseGenerator;
                    return vm;
                }
            });

            TestCaseCreationSteps.Add(new StepDescriptor
            {
                Id = "clarifying-questions",
                DisplayName = "Clarifying Questions",
                Badge = "",
                CreateViewModel = svc => new ClarifyingQuestionsViewModel(_persistence)
            });

            TestCaseCreationSteps.Add(new StepDescriptor
            {
                Id = "testcase-creation",
                DisplayName = "Test Case Creation",
                Badge = "",
                CreateViewModel = svc => new TestCaseCreationViewModel()
            });

            SelectedStep = TestCaseCreationSteps.FirstOrDefault(s => s.CreateViewModel != null);

            _logger?.LogDebug("MainViewModel constructed (DI)");
        }

        /// <summary>
        /// Parameterless constructor for design-time and fallback. Uses no-op services.
        /// </summary>
        public MainViewModel()
        {
            _requirementService = new NoOpRequirementService();
            _persistence = new NoOpPersistenceService();
            _workspaceHeaderViewModel = new WorkspaceHeaderViewModel();
            Navigation = new NavigationViewModel();
            _fileDialog = new NoOpFileDialogService();
            _services = new SimpleServiceProviderStub();

            _logger = null;

            HeaderViewModel = _workspaceHeaderViewModel;

            // Requirements ObservableProperty already initialised by backing field
            // Create navigator with null logger (safe)
            _requirementsNavigator = new RequirementsIndexViewModel(
                Requirements,
                () => CurrentRequirement,
                r => CurrentRequirement = r,
                () => { },
                logger: null);

            TestCaseCreationSteps.Add(new StepDescriptor { Id = "requirements", DisplayName = "Requirements", CreateViewModel = svc => null! });
        }

        // -----------------------------
        // Header wiring and helpers
        // -----------------------------
        public void CreateAndAssignTestCaseCreatorHeader()
        {
            if (_testCaseCreatorHeader != null)
            {
                HeaderViewModel = _testCaseCreatorHeader;
                UpdateTestCaseCreatorHeaderFromState();
                return;
            }

            var vm = new TestCaseCreatorHeaderViewModel
            {
                OpenRequirementsCommand = new RelayCommand(() => Header_OpenRequirements()),
                OpenWorkspaceCommand = new RelayCommand(() => Header_OpenWorkspace()),
                SaveCommand = new RelayCommand(() => { TryInvokeSaveWorkspace(); })
            };

            _testCaseCreatorHeader = vm;
            HeaderViewModel = vm;

            UpdateTestCaseCreatorHeaderFromState();
            WireHeaderSubscriptions();
        }

        private void WireHeaderSubscriptions()
        {
            if (_headerSubscriptionsWired) return;
            _headerSubscriptionsWired = true;

            try
            {
                if (Requirements != null)
                {
                    Requirements.CollectionChanged += Header_Requirements_CollectionChanged;
                    foreach (var r in Requirements) TryWireRequirementForHeader(r);
                }
            }
            catch { /* best-effort */ }

            try
            {
                LlmConnectionManager.ConnectionChanged += LlmConnectionManager_ConnectionChanged;
            }
            catch { /* ignore */ }

            TryWireDynamicTestCaseGenerator();

            try { this.PropertyChanged += MainViewModel_PropertyChanged; } catch { }
        }

        private void UnwireHeaderSubscriptions()
        {
            if (!_headerSubscriptionsWired) return;
            _headerSubscriptionsWired = false;

            try
            {
                if (Requirements != null)
                {
                    Requirements.CollectionChanged -= Header_Requirements_CollectionChanged;
                    foreach (var r in Requirements) TryUnwireRequirementForHeader(r);
                }
            }
            catch { }

            try { LlmConnectionManager.ConnectionChanged -= LlmConnectionManager_ConnectionChanged; } catch { }
            try
            {
                if (_linkedTestCaseGeneratorInpc != null)
                {
                    _linkedTestCaseGeneratorInpc.PropertyChanged -= TestCaseGenerator_PropertyChanged;
                    _linkedTestCaseGeneratorInpc = null;
                }
            }
            catch { }
            try { this.PropertyChanged -= MainViewModel_PropertyChanged; } catch { }
        }

        private void LlmConnectionManager_ConnectionChanged(bool connected)
        {
            if (_testCaseCreatorHeader == null) return;
            try
            {
                _testCaseCreatorHeader.IsLlmConnected = connected;
            }
            catch { /* swallow */ }
        }

        private void MainViewModel_PropertyChanged(object? sender, PropertyChangedEventArgs e)
        {
            if (e.PropertyName == nameof(CurrentRequirement) || e.PropertyName == nameof(WorkspacePath) || e.PropertyName == nameof(CurrentWorkspace))
            {
                UpdateTestCaseCreatorHeaderFromState();
            }
        }

        private void TestCaseGenerator_PropertyChanged(object? sender, PropertyChangedEventArgs e)
        {
            if (_testCaseCreatorHeader == null) return;

            if (string.Equals(e.PropertyName, "IsLlmAvailable", StringComparison.Ordinal)
                || string.Equals(e.PropertyName, "IsLlmBusy", StringComparison.Ordinal))
            {
                try
                {
                    bool connected = false;
                    try
                    {
                        var tcg = GetTestCaseGeneratorInstance();
                        if (tcg != null)
                        {
                            var avProp = tcg.GetType().GetProperty("IsLlmAvailable", BindingFlags.Public | BindingFlags.Instance);
                            var busyProp = tcg.GetType().GetProperty("IsLlmBusy", BindingFlags.Public | BindingFlags.Instance);
                            var isAvailable = avProp != null && avProp.GetValue(tcg) is bool bav && bav;
                            var isBusy = busyProp != null && busyProp.GetValue(tcg) is bool bbusy && bbusy;
                            connected = isAvailable && !isBusy;
                        }
                    }
                    catch { connected = false; }

                    _testCaseCreatorHeader.IsLlmConnected = connected;
                }
                catch { /* swallow */ }
            }
        }

        private void Header_Requirements_CollectionChanged(object? sender, NotifyCollectionChangedEventArgs e)
        {
            if (e.OldItems != null)
            {
                foreach (Requirement r in e.OldItems) TryUnwireRequirementForHeader(r);
            }
            if (e.NewItems != null)
            {
                foreach (Requirement r in e.NewItems) TryWireRequirementForHeader(r);
            }
            UpdateTestCaseCreatorHeaderFromState();
        }

        private void TryWireRequirementForHeader(Requirement? r)
        {
            if (r == null) return;
            try { r.PropertyChanged += Requirement_ForHeader_PropertyChanged; } catch { }
        }

        private void TryUnwireRequirementForHeader(Requirement? r)
        {
            if (r == null) return;
            try { r.PropertyChanged -= Requirement_ForHeader_PropertyChanged; } catch { }
        }

        private void Requirement_ForHeader_PropertyChanged(object? sender, PropertyChangedEventArgs e)
        {
            if (e.PropertyName == nameof(Requirement.CurrentResponse) ||
                e.PropertyName == nameof(Requirement.GeneratedTestCases))
            {
                UpdateTestCaseCreatorHeaderFromState();
            }
        }

        private void UpdateTestCaseCreatorHeaderFromState()
        {
            var h = _testCaseCreatorHeader;
            if (h == null) return;

            try
            {
                string? wsName = null;
                try
                {
                    if (!string.IsNullOrWhiteSpace(WorkspacePath))
                        wsName = Path.GetFileName(WorkspacePath);
                    else if (CurrentWorkspace?.SourceDocPath != null)
                        wsName = Path.GetFileName(CurrentWorkspace.SourceDocPath);
                }
                catch { wsName = null; }
                h.WorkspaceName = string.IsNullOrWhiteSpace(wsName) ? "Workspace" : wsName;

                h.CurrentRequirementName = CurrentRequirement?.Name ?? CurrentRequirement?.Item ?? string.Empty;

                int count = 0;
                try
                {
                    count = Requirements?.Count(r =>
                    {
                        try
                        {
                            return (r != null) && ((r.GeneratedTestCases != null && r.GeneratedTestCases.Count > 0) || r.HasGeneratedTestCase);
                        }
                        catch { return false; }
                    }) ?? 0;
                }
                catch { count = 0; }
                h.RequirementsWithTestCasesCount = count;

                try
                {
                    bool fallbackConnected = false;
                    try
                    {
                        var tcg = GetTestCaseGeneratorInstance();
                        if (tcg != null)
                        {
                            var avProp = tcg.GetType().GetProperty("IsLlmAvailable", BindingFlags.Public | BindingFlags.Instance);
                            var busyProp = tcg.GetType().GetProperty("IsLlmBusy", BindingFlags.Public | BindingFlags.Instance);
                            var isAvailable = avProp != null && avProp.GetValue(tcg) is bool bav && bav;
                            var isBusy = busyProp != null && busyProp.GetValue(tcg) is bool bbusy && bbusy;
                            fallbackConnected = isAvailable && !isBusy;
                        }
                    }
                    catch { fallbackConnected = false; }

                    h.IsLlmConnected = LlmConnectionManager.IsConnected || fallbackConnected;
                }
                catch { /* ignore */ }
            }
            catch { /* ignore */ }
        }

        public void SetLlmConnection(bool connected)
        {
            LlmConnectionManager.SetConnected(connected);
        }

        private void Header_OpenRequirements()
        {
            try
            {
                var reqStep = TestCaseCreationSteps.FirstOrDefault(s => string.Equals(s.Id, "requirements", StringComparison.OrdinalIgnoreCase));
                if (reqStep != null) SelectedStep = reqStep;
                SelectedMenuSection = "Requirements";
                TryInvokeSetTransientStatus("Opened requirements.", 2);
            }
            catch (Exception ex)
            {
                _logger?.LogWarning(ex, "[Header_OpenRequirements] failed");
                TryInvokeSetTransientStatus("Failed to open requirements.", 4);
            }
        }

        private void Header_OpenWorkspace()
        {
            try
            {
                TryInvokeLoadWorkspace();
            }
            catch (Exception ex)
            {
                _logger?.LogWarning(ex, "[Header_OpenWorkspace] failed");
                TryInvokeSetTransientStatus("Failed to open workspace.", 4);
            }
        }

        private Task Header_SaveAsync()
        {
            try
            {
                TryInvokeSaveWorkspace();
                return Task.CompletedTask;
            }
            catch (Exception ex)
            {
                _logger?.LogWarning(ex, "[Header_SaveAsync] failed");
                TryInvokeSetTransientStatus("Failed to save workspace.", 4);
                return Task.CompletedTask;
            }
        }

        // ----------------- helpers that avoid compile-time coupling -----------------

        private object? GetTestCaseGeneratorInstance()
        {
            try
            {
                var prop = this.GetType().GetProperty("TestCaseGenerator", BindingFlags.Public | BindingFlags.Instance | BindingFlags.IgnoreCase);
                return prop?.GetValue(this);
            }
            catch { return null; }
        }

        private void TryWireDynamicTestCaseGenerator()
        {
            try
            {
                var tcg = GetTestCaseGeneratorInstance();
                if (tcg is INotifyPropertyChanged inpc && !ReferenceEquals(inpc, _linkedTestCaseGeneratorInpc))
                {
                    if (_linkedTestCaseGeneratorInpc != null)
                    {
                        _linkedTestCaseGeneratorInpc.PropertyChanged -= TestCaseGenerator_PropertyChanged;
                        _linkedTestCaseGeneratorInpc = null;
                    }

                    inpc.PropertyChanged += TestCaseGenerator_PropertyChanged;
                    _linkedTestCaseGeneratorInpc = inpc;
                }
            }
            catch { /* ignore */ }
        }

        private void TryInvokeSaveWorkspace()
        {
            try
            {
                var cmdProp = this.GetType().GetProperty("SaveWorkspaceCommand", BindingFlags.Public | BindingFlags.Instance | BindingFlags.IgnoreCase)
                            ?? this.GetType().GetProperty("SaveCommand", BindingFlags.Public | BindingFlags.Instance | BindingFlags.IgnoreCase);
                if (cmdProp != null && cmdProp.GetValue(this) is ICommand cmd && cmd.CanExecute(null))
                {
                    cmd.Execute(null);
                    return;
                }

                var m = this.GetType().GetMethod("SaveWorkspace", BindingFlags.Public | BindingFlags.Instance | BindingFlags.IgnoreCase)
                     ?? this.GetType().GetMethod("Save", BindingFlags.Public | BindingFlags.Instance | BindingFlags.IgnoreCase);
                if (m != null)
                {
                    m.Invoke(this, Array.Empty<object>());
                    return;
                }
            }
            catch { /* ignore */ }
        }

        private void TryInvokeLoadWorkspace()
        {
            try
            {
                var cmdProp = this.GetType().GetProperty("LoadWorkspaceCommand", BindingFlags.Public | BindingFlags.Instance | BindingFlags.IgnoreCase)
                            ?? this.GetType().GetProperty("OpenWorkspaceCommand", BindingFlags.Public | BindingFlags.Instance | BindingFlags.IgnoreCase);
                if (cmdProp != null && cmdProp.GetValue(this) is ICommand cmd && cmd.CanExecute(null))
                {
                    cmd.Execute(null);
                    return;
                }

                var m = this.GetType().GetMethod("LoadWorkspace", BindingFlags.Public | BindingFlags.Instance | BindingFlags.IgnoreCase)
                     ?? this.GetType().GetMethod("OpenWorkspace", BindingFlags.Public | BindingFlags.Instance | BindingFlags.IgnoreCase);
                if (m != null)
                {
                    m.Invoke(this, Array.Empty<object>());
                    return;
                }
            }
            catch { /* ignore */ }
        }

        private void TryInvokeSetTransientStatus(string msg, int seconds)
        {
            try
            {
                var m = this.GetType().GetMethod("SetTransientStatus", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.IgnoreCase)
                     ?? this.GetType().GetMethod("ShowTransientStatus", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.IgnoreCase);
                if (m != null)
                {
                    m.Invoke(this, new object[] { msg, seconds });
                    return;
                }

                var prop = this.GetType().GetProperty("StatusMessage", BindingFlags.Public | BindingFlags.Instance | BindingFlags.IgnoreCase)
                        ?? this.GetType().GetProperty("Status", BindingFlags.Public | BindingFlags.Instance | BindingFlags.IgnoreCase);
                if (prop != null && prop.CanWrite)
                {
                    prop.SetValue(this, msg);
                }
            }
            catch { /* ignore */ }
        }

        // -----------------------------
        // Collection / navigation helpers
        // -----------------------------
        private void RequirementsOnCollectionChanged(object? sender, NotifyCollectionChangedEventArgs e)
        {
            OnPropertyChanged(nameof(TotalRequirementsCount));
            OnPropertyChanged(nameof(RequirementPositionDisplay));
            _requirementsNavigator?.NotifyCurrentRequirementChanged();
        }

        public int TotalRequirementsCount => Requirements?.Count ?? 0;
        public string RequirementPositionDisplay =>
            Requirements == null || Requirements.Count == 0 || CurrentRequirement == null
                ? string.Empty
                : $"{Requirements.IndexOf(CurrentRequirement) + 1} of {Requirements.Count}";

        private void CommitPendingEdits() => Keyboard.ClearFocus();

        // --- Commands decorated for source generator convenience (but we provide explicit ICommand props above) ---
        [RelayCommand]
        private async Task ImportWordAsync()
        {
            var dlg = new OpenFileDialog
            {
                Title = "Open requirements document (.docx)",
                Filter = "Word Documents (*.docx)|*.docx",
                RestoreDirectory = true
            };
            if (dlg.ShowDialog() != true)
            {
                SetTransientStatus("Import cancelled.", 2);
                return;
            }
            await ImportFromPathAsync(dlg.FileName, replace: true);
        }

        [RelayCommand]
        private async Task ReloadAsync()
        {
            if (string.IsNullOrWhiteSpace(CurrentSourcePath))
            {
                SetTransientStatus("No source loaded to reload.", 3);
                return;
            }
            await ImportFromPathAsync(CurrentSourcePath!, replace: true);
        }

        [RelayCommand]
        private async Task SaveWorkspaceAsync()
        {
            if (Requirements == null || Requirements.Count == 0)
            {
                SetTransientStatus("Nothing to save.", 2);
                return;
            }

            var suggested = $"{(string.IsNullOrWhiteSpace(Path.GetFileNameWithoutExtension(WordFilePath)) ? "Workspace" : Path.GetFileNameWithoutExtension(WordFilePath))}.tcex.json";
            var defaultFolder = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments), "TestCaseEditorApp", "Sessions");
            Directory.CreateDirectory(defaultFolder);

            var chosen = _fileDialog.ShowSaveFile(
                title: "Save Workspace",
                suggestedFileName: suggested,
                filter: "Test Case Editor Session|*.tcex.json|JSON|*.json|All Files|*.*",
                defaultExt: ".tcex.json",
                initialDirectory: defaultFolder);

            if (string.IsNullOrWhiteSpace(chosen))
            {
                SetTransientStatus("Save cancelled.", 2);
                return;
            }

            WorkspacePath = chosen;
            var ws = new Workspace
            {
                SourceDocPath = CurrentSourcePath,
                Requirements = Requirements.ToList()
            };

            try
            {
                WorkspaceService.Save(WorkspacePath!, ws);
                CurrentWorkspace = ws;
                HasUnsavedChanges = false;
                SetTransientStatus($"Saved workspace: {Path.GetFileName(WorkspacePath)}", 4);
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Failed to save workspace: {ex.Message}", "Save error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        [RelayCommand]
        private void LoadWorkspace()
        {
            var ofd = new Microsoft.Win32.OpenFileDialog
            {
                Title = "Open Saved Session",
                Filter = "Test Case Editor Session|*.tcex.json",
                DefaultExt = ".tcex.json",
                RestoreDirectory = true,
                InitialDirectory = !string.IsNullOrWhiteSpace(WorkspacePath) ? Path.GetDirectoryName(WorkspacePath) : Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments)
            };

            if (ofd.ShowDialog() != true) return;

            WorkspacePath = ofd.FileName;
            try
            {
                var ws = WorkspaceService.Load<Workspace>(WorkspacePath!);
                if (ws == null)
                {
                    SetTransientStatus("Failed to load workspace (file empty or invalid).", 4);
                    return;
                }

                CurrentWorkspace = ws;
                Requirements.Clear();
                foreach (var r in ws.Requirements ?? Enumerable.Empty<Requirement>())
                    Requirements.Add(r);

                CurrentRequirement = Requirements.FirstOrDefault();
                CurrentSourcePath = ws.SourceDocPath;
                SetTransientStatus($"Opened workspace: {Path.GetFileName(WorkspacePath)} • {Requirements.Count} requirements", 4);
                HasUnsavedChanges = false;
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Failed to load workspace: {ex.Message}", "Load error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        // Navigation methods (ICommand-backed)
        private void NextRequirement()
        {
            CommitPendingEdits();
            if (Requirements.Count == 0 || CurrentRequirement == null) return;
            int idx = Requirements.IndexOf(CurrentRequirement);
            if (idx >= 0 && idx < Requirements.Count - 1) CurrentRequirement = Requirements[idx + 1];
        }

        private void PreviousRequirement()
        {
            CommitPendingEdits();
            if (Requirements.Count == 0 || CurrentRequirement == null) return;
            int idx = Requirements.IndexOf(CurrentRequirement);
            if (idx > 0) CurrentRequirement = Requirements[idx - 1];
        }

        private void NextWithoutTestCase()
        {
            CommitPendingEdits();

            if (Requirements == null || Requirements.Count == 0)
            {
                SetTransientStatus("No requirements available.", 3);
                return;
            }

            int count = Requirements.Count;
            int startIdx = (CurrentRequirement == null) ? -1 : Requirements.IndexOf(CurrentRequirement);
            if (startIdx < -1) startIdx = -1;

            bool HasTestCase(Requirement r)
            {
                try { return r != null && r.HasGeneratedTestCase; }
                catch { return false; }
            }

            for (int step = 1; step <= count; step++)
            {
                int idx = startIdx + step;
                if (!WrapOnNextWithoutTestCase && idx >= count) break;
                int candidate = idx % count;
                var req = Requirements[candidate];
                if (!HasTestCase(req))
                {
                    CurrentRequirement = req;
                    return;
                }
            }

            SetTransientStatus("No next requirement without a test case found.", 4);
        }

        // Requirement wiring helpers
        private Requirement? _prevReq;
        private void UnhookOldRequirement()
        {
            if (_prevReq != null) _prevReq.PropertyChanged -= CurrentRequirement_PropertyChanged;
            _prevReq = null;
        }

        private void HookNewRequirement(Requirement? r)
        {
            if (r != null) { _prevReq = r; _prevReq.PropertyChanged += CurrentRequirement_PropertyChanged; }
        }

        partial void OnCurrentRequirementChanged(Requirement? value)
        {
            UnhookOldRequirement();
            HookNewRequirement(value);

            _requirementsNavigator?.NotifyCurrentRequirementChanged();

            try
            {
                _workspaceHeaderView_update(value);
            }
            catch (Exception ex)
            {
                _logger?.LogDebug(ex, "[OnCurrentRequirementChanged] header update failed");
            }

            LooseTables.Clear();
            LooseParagraphs.Clear();
            OnPropertyChanged(nameof(RequirementPositionDisplay));

            if (value == null)
            {
                try
                {
                    _testCaseGenerator?.ResetForRequirement(null);
                    var _vcvm = _testCaseGenerator?.VerificationCaseVM;
                    if (_vcvm != null)
                    {
                        _vcvm.ReqId = string.Empty;
                        _vcvm.ReqName = string.Empty;
                        _vcvm.ReqDescription = string.Empty;
                        _vcvm.Methods = Array.Empty<VMVerMethod>();
                        _vcvm.SelectedMethod = VMVerMethod.Inspection;
                        _vcvm.ImportedRationale = null;
                        _vcvm.ImportedValidationEvidence = null;
                        _vcvm.ImportedSupportingNotes = null;
                        _vcvm.ImportedSupportingTables = null;
                        _vcvm.GenerationResult = string.Empty;
                    }
                }
                catch (Exception ex)
                {
                    _logger?.LogDebug(ex, "[OnCurrentRequirementChanged] VCVM clear error");
                }
                return;
            }

            try { BuildSupportingInfoFromRequirement(value); } catch (Exception ex) { _logger?.LogDebug(ex, "[OnCurrentRequirementChanged] BuildSupportingInfo failed"); }

            try { _testCaseGenerator?.ResetForRequirement(value); WireGeneratorCallbacks(); } catch (Exception ex) { _logger?.LogDebug(ex, "[OnCurrentRequirementChanged] Reset/wire failed"); }

            var vcvm = _testCaseGenerator?.VerificationCaseVM;
            if (vcvm != null)
            {
                try
                {
                    vcvm.ReqId = value.Item ?? value.Name ?? string.Empty;
                    vcvm.ReqName = value.Name ?? string.Empty;
                    vcvm.ReqDescription = value.Description ?? string.Empty;

                    var list = value.VerificationMethods;
                    IReadOnlyList<VMVerMethod> methods = (list != null) ? list.AsReadOnly() : Array.Empty<VMVerMethod>();
                    vcvm.Methods = methods;
                    vcvm.SelectedMethod = value.Method != default ? value.Method : VMVerMethod.Inspection;
                    vcvm.ImportedRationale = value.Rationale;
                    vcvm.ImportedValidationEvidence = value.ValidationEvidence;
                    vcvm.ImportedSupportingNotes = FormatSupportingNotes(value);
                    vcvm.ImportedSupportingTables = FormatSupportingTables(value);

                    vcvm.GenerationResult = GetLatestLlmDraftText(value);
                    _testCaseGenerator.LlmOutput = BuildStrictOutputFromSaved(value);
                }
                catch (Exception ex)
                {
                    _logger?.LogDebug(ex, "[OnCurrentRequirementChanged] VCVM populate failed");
                }
            }

            OnPropertyChanged(nameof(RequirementPositionDisplay));
        }

        private void _workspaceHeaderView_update(Requirement? value)
        {
            try
            {
                _workspaceHeaderViewModel.CurrentRequirementTitle = value?.Name ?? string.Empty;
                _workspaceHeaderViewModel.CurrentRequirementSummary = ShortSummary(value?.Description);
                _workspaceHeaderViewModel.CurrentRequirementId = value?.Item ?? string.Empty;
                _workspaceHeaderViewModel.CurrentRequirementStatus = value?.Status ?? string.Empty;
            }
            catch { /* ignore */ }
        }

        private void CurrentRequirement_PropertyChanged(object? sender, PropertyChangedEventArgs e)
        {
            if (e.PropertyName == nameof(Requirement.Name) || e.PropertyName == nameof(Requirement.Description))
            {
                if (sender is Requirement r)
                {
                    try
                    {
                        _workspaceHeaderViewModel.CurrentRequirementTitle = r.Name ?? string.Empty;
                        _workspaceHeaderViewModel.CurrentRequirementSummary = ShortSummary(r.Description);
                        _workspaceHeaderViewModel.CurrentRequirementId = r.Item ?? string.Empty;
                    }
                    catch { /* ignore */ }
                }
            }
        }

        // --- Import implementation (updated to preserve collection instance and use logger) ---
        private async Task ImportFromPathAsync(string path, bool replace)
        {
            if (replace && HasUnsavedChanges && Requirements.Count > 0)
            {
                var res = MessageBox.Show(
                    "You have unsaved changes. Replace the current requirements with the new import?",
                    "Unsaved changes", MessageBoxButton.YesNo, MessageBoxImage.Warning);
                if (res != MessageBoxResult.Yes)
                {
                    SetTransientStatus("Import canceled.", 2);
                    _logger?.LogInformation("Import canceled by user (unsaved changes).");
                    return;
                }
            }

            try
            {
                var defaultFolder = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments), "TestCaseEditorApp", "Sessions");
                Directory.CreateDirectory(defaultFolder);

                var suggested = FileNameHelper.GenerateUniqueFileName(Path.GetFileNameWithoutExtension(path), ".tcex.json");

                var chosen = _file_dialog_show_save_helper(suggested, defaultFolder);

                if (string.IsNullOrWhiteSpace(chosen))
                {
                    SetTransientStatus("Import canceled (no workspace name selected).", 2);
                    _logger?.LogInformation("Import canceled: no workspace name selected.");
                    return;
                }

                WorkspacePath = FileNameHelper.EnsureUniquePath(Path.GetDirectoryName(chosen)!, Path.GetFileName(chosen));

                SetTransientStatus($"Importing {Path.GetFileName(path)}…", 0);
                _logger?.LogInformation("Starting import of '{Path}'", path);

                var sw = Stopwatch.StartNew();

                _logger?.LogDebug("requirementService = {RequirementServiceType}", _requirementService?.GetType().FullName ?? "<null>");

                var reqs = await Task.Run(() => _requirement_service_call_for_import(path));
                _logger?.LogInformation("Parser returned {Count} requirement(s)", reqs?.Count ?? 0);

                sw.Stop();

                if (reqs == null || reqs.Count == 0)
                {
                    try
                    {
                        var tmp = Path.Combine(Path.GetTempPath(), $"tce_import_debug_{DateTime.UtcNow:yyyyMMdd_HHmmss}.txt");
                        using var swf = new StreamWriter(tmp, false, new UTF8Encoding(encoderShouldEmitUTF8Identifier: true));
                        swf.WriteLine("Import debug snapshot");
                        swf.WriteLine("Source DOCX: " + path);
                        swf.WriteLine("Parsed requirement count: 0");
                        swf.WriteLine("");

                        swf.WriteLine("Dumping first non-empty DOCX paragraphs for inspection (up to 120):");
                        try
                        {
                            using var wordDoc = DocumentFormat.OpenXml.Packaging.WordprocessingDocument.Open(path, false);
                            var paragraphs = wordDoc.MainDocumentPart?.Document?.Body?.Elements<DocumentFormat.OpenXml.Wordprocessing.Paragraph>()
                                                .Select(p => (p.InnerText ?? "").Trim()).Where(s => s.Length > 0).ToList() ?? new List<string>();

                            for (int i = 0; i < Math.Min(120, paragraphs.Count); i++)
                                swf.WriteLine($"[{i + 1}] {paragraphs[i]}");
                        }
                        catch (Exception ex)
                        {
                            swf.WriteLine("Failed to read DOCX paragraphs for debug: " + ex.Message);
                            _logger?.LogWarning(ex, "Failed to read DOCX paragraphs while building diagnostic snapshot for '{Path}'", path);
                        }

                        swf.Flush();
                        _logger?.LogInformation("Wrote parse debug to: {TempFile}", tmp);
                    }
                    catch (Exception ex)
                    {
                        _logger?.LogWarning(ex, "Diagnostic snapshot failed while importing '{Path}'", path);
                    }
                }

                CurrentWorkspace = new Workspace
                {
                    SourceDocPath = path,
                    Requirements = reqs.ToList()
                };

                object? template = null;
                try { template = DefaultsHelper.LoadProjectDefaultsTemplate(); } catch (Exception ex) { _logger?.LogWarning(ex, "DefaultsHelper failed"); }

                if (template is DefaultsBlock dbTemplate)
                {
                    CurrentWorkspace.Defaults = dbTemplate;
                }
                else if (template is DefaultsCatalogDto catalogDto)
                {
                    CurrentWorkspace.Defaults = new DefaultsBlock
                    {
                        Version = 1,
                        Catalog = catalogDto,
                        State = new DefaultsState { SelectedPreset = "Bench (default)" }
                    };
                }
                else if (template != null)
                {
                    try
                    {
                        dynamic dyn = template;
                        var catalog = new DefaultsCatalogDto();
                        try { catalog.Items = dyn.Items; } catch { }
                        try { catalog.Presets = dyn.Presets; } catch { }

                        CurrentWorkspace.Defaults = new DefaultsBlock
                        {
                            Version = 1,
                            Catalog = catalog,
                            State = new DefaultsState { SelectedPreset = "Bench (default)" }
                        };
                    }
                    catch (Exception ex)
                    {
                        _logger?.LogWarning(ex, "Failed to adapt template object to DefaultsBlock; falling back to starter defaults");
                        CurrentWorkspace.Defaults = new DefaultsBlock { Version = 1, Catalog = null, State = new DefaultsState { SelectedPreset = "Bench (default)" } };
                    }
                }
                else
                {
                    CurrentWorkspace.Defaults = new DefaultsBlock { Version = 1, Catalog = null, State = new DefaultsState { SelectedPreset = "Bench (default)" } };
                }

                reqs = reqs ?? new List<Requirement>();

                try
                {
                    Requirements.CollectionChanged -= RequirementsOnCollectionChanged;

                    if (Application.Current?.Dispatcher?.CheckAccess() == true)
                    {
                        Requirements.Clear();
                        foreach (var r in reqs) Requirements.Add(r);
                    }
                    else
                    {
                        Application.Current?.Dispatcher?.Invoke(() =>
                        {
                            Requirements.Clear();
                            foreach (var r in reqs) Requirements.Add(r);
                        });
                    }
                }
                finally
                {
                    Requirements.CollectionChanged += RequirementsOnCollectionChanged;
                }

                CurrentWorkspace.Requirements = Requirements.ToList();

                try
                {
                    if (!string.IsNullOrWhiteSpace(WorkspacePath))
                        WorkspaceService.Save(WorkspacePath!, CurrentWorkspace);
                }
                catch (Exception ex)
                {
                    _logger?.LogWarning(ex, "WorkspaceService.Save failed for path '{WorkspacePath}'", WorkspacePath);
                }

                HasUnsavedChanges = false;

                try { _testCaseGenerator?.LoadDefaultsFromWorking(CurrentWorkspace.Defaults ?? new DefaultsBlock()); } catch (Exception ex) { _logger?.LogWarning(ex, "TestCaseGenerator.LoadDefaultsFromWorking failed"); }

                CurrentRequirement = Requirements.FirstOrDefault();
                RefreshSupportingInfo();

                var db = CurrentWorkspace.Defaults ?? new DefaultsBlock();
                try
                {
                    if (db != null && db.Catalog?.Items != null)
                    {
                        foreach (var it in db.Catalog.Items)
                            _logger?.LogDebug("DefaultItem: Key='{Key}', Name='{Name}'", it?.Key, it?.Name);
                    }
                }
                catch (Exception ex) { _logger?.LogWarning(ex, "Exception while logging defaults"); }

                try { _testCaseGenerator?.LoadDefaultsFromWorking(db); } catch (Exception ex) { _logger?.LogWarning(ex, "TestCaseGenerator.LoadDefaultsFromWorking (2) failed"); }

                WordFilePath = null;
                CurrentSourcePath = null;

                ComputeDraftedCount();
                RaiseCounterChanges();

                _requirementsNavigator?.NotifyCurrentRequirementChanged();

                try
                {
                    var navType = _requirementsNavigator?.GetType().FullName ?? "<null>";
                    bool navigatorRefsRequirements = false;
                    try
                    {
                        object? navColObj = null;
                        var nav = _requirementsNavigator;
                        if (nav != null)
                        {
                            var p = nav.GetType().GetProperty("Requirements", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
                            if (p != null) navColObj = p.GetValue(nav);
                            else
                            {
                                var f = nav.GetType().GetField("_requirements", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public)
                                        ?? nav.GetType().GetField("requirements", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);
                                if (f != null) navColObj = f.GetValue(nav);
                            }
                        }
                        navigatorRefsRequirements = ReferenceEquals(navColObj, Requirements);
                    }
                    catch (Exception ex) { _logger?.LogDebug(ex, "Navigator reflection check failed"); }
                    _logger?.LogInformation("[NAV DIAG] Requirements.Count={Count}; NavigatorType={Type}; NavigatorRefsRequirements={Refs}",
                        Requirements?.Count ?? -1, navType, navigatorRefsRequirements);
                }
                catch (Exception ex) { _logger?.LogDebug(ex, "Navigator diagnostic logging failed"); }

                if (Requirements.Count == 0)
                {
                    SetTransientStatus($"Import completed: 0 requirements — see logs in LocalAppData\\TestCaseEditorApp\\imports", 8);
                    try
                    {
                        var folder = Path.GetDirectoryName(WorkspacePath) ?? Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);
                        Process.Start(new ProcessStartInfo("explorer.exe", $"\"{folder}\"") { UseShellExecute = true });
                    }
                    catch (Exception ex)
                    {
                        _logger?.LogDebug(ex, "Failed to open folder explorer");
                    }
                }
                else
                {
                    _logger?.LogInformation("CurrentRequirement set to: {Item} • {Name} (Total: {Total})",
                        CurrentRequirement?.Item, CurrentRequirement?.Name, Requirements.Count);
                }

                SetTransientStatus($"💾 Workspace created: {Path.GetFileName(WorkspacePath)} • {Requirements.Count} requirement(s) • {sw.ElapsedMilliseconds} ms", 6);
                _logger?.LogInformation("final status: {StatusMessage}", StatusMessage);
            }
            catch (NotSupportedException ex)
            {
                Status = ex.Message;
                _logger?.LogError(ex, "NotSupportedException during import");
            }
            catch (IOException ex)
            {
                Status = "Close the Word file and try again.";
                _logger?.LogError(ex, "IOException during import");
            }
            catch (Exception ex)
            {
                SaveSessionAuto();
                Status = "Import failed: " + ex.Message;
                _logger?.LogError(ex, "Exception during import");
            }
        }

        // Wrap requirement service call so it's easy to adapt if your real interface differs.
        private List<Requirement> _requirement_service_call_for_import(string path)
        {
            return _requirementService?.ImportRequirementsFromJamaAllDataDocx(path) ?? new List<Requirement>();
        }

        private string _file_dialog_show_save_helper(string suggestedFileName, string initialDirectory)
            => _fileDialog.ShowSaveFile(title: "Create Workspace", suggestedFileName: suggestedFileName, filter: "Test Case Editor Session|*.tcex.json|JSON|*.json|All Files|*.*", defaultExt: ".tcex.json", initialDirectory: initialDirectory);

        private void SetTransientStatus(string message, int seconds = 3)
        {
            StatusMessage = message;
            try { _statusTimer?.Stop(); } catch { }
            if (seconds > 0)
            {
                _statusTimer = new DispatcherTimer { Interval = TimeSpan.FromSeconds(seconds) };
                _statusTimer.Tick += (_, __) => { try { _statusTimer?.Stop(); } catch { } StatusMessage = null; };
                _statusTimer.Start();
            }
        }

        private IPersistenceService WorkspaceService => _persistence;

        private void SaveSessionAuto()
        {
            try
            {
                if (!string.IsNullOrWhiteSpace(WorkspacePath) && WorkspaceService != null && CurrentWorkspace != null)
                    WorkspaceService.Save(WorkspacePath!, CurrentWorkspace);
            }
            catch (Exception ex) { _logger?.LogDebug(ex, "[SaveSessionAuto] failed"); }
        }

        private void RefreshSupportingInfo()
        {
            if (CurrentRequirement != null) BuildSupportingInfoFromRequirement(CurrentRequirement);
        }

        private void BuildSupportingInfoFromRequirement(Requirement req)
        {
            LooseTables.Clear();
            LooseParagraphs.Clear();

            try
            {
                if (req?.LooseContent?.Paragraphs != null)
                {
                    foreach (var p in req.LooseContent.Paragraphs) LooseParagraphs.Add(p);
                }

                if (req?.LooseContent?.Tables != null)
                {
                    foreach (var t in req.LooseContent.Tables)
                    {
                        var vm = new LooseTableViewModel { Title = t.EditableTitle };
                        LooseTables.Add(vm);
                    }
                }
            }
            catch (Exception ex) { _logger?.LogDebug(ex, "[BuildSupportingInfoFromRequirement] failed"); }
        }

        private void ComputeDraftedCount() { /* app-specific */ }
        private void RaiseCounterChanges() { /* app-specific */ }
        private void WireGeneratorCallbacks() { /* wire generator events if needed */ }

        private string? FormatSupportingNotes(Requirement req) => req?.Description;
        private IEnumerable<TableDto>? FormatSupportingTables(Requirement req) => Enumerable.Empty<TableDto>();
        private string GetLatestLlmDraftText(Requirement req) => string.Empty;
        private string BuildStrictOutputFromSaved(Requirement req) => string.Empty;

        public string? Status
        {
            get => StatusMessage;
            set
            {
                if (StatusMessage == value) return;
                StatusMessage = value;
                OnPropertyChanged(nameof(Status));
                OnPropertyChanged(nameof(StatusMessage));
            }
        }

        partial void OnSelectedMenuSectionChanged(string? value)
        {
            try
            {
                switch (value)
                {
                    case "TestCase":
                        HeaderViewModel = new TestCaseHeaderViewModel();
                        break;
                    case "TestFlow":
                        HeaderViewModel = new TestFlowHeaderViewModel();
                        break;
                    default:
                        HeaderViewModel = _workspaceHeaderViewModel;
                        break;
                }
            }
            catch
            {
                HeaderViewModel = _workspaceHeaderViewModel;
            }
        }

        partial void OnWorkspacePathChanged(string? value)
        {
            try
            {
                if (!string.IsNullOrWhiteSpace(value))
                {
                    _workspaceHeaderViewModel.WorkspaceName = Path.GetFileName(value) ?? value;
                    _workspaceHeaderViewModel.SourceInfo = value;
                }
                else
                {
                    _workspaceHeaderViewModel.WorkspaceName = "Workspace";
                    _workspaceHeaderViewModel.SourceInfo = null;
                }
            }
            catch { /* ignore */ }
        }

        partial void OnHasUnsavedChangesChanged(bool value)
        {
            try { _workspaceHeaderViewModel.HasUnsavedChanges = value; } catch { }
        }

        private static string ShortSummary(string? description, int maxLength = 200)
        {
            if (string.IsNullOrWhiteSpace(description)) return string.Empty;
            var firstLine = description.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries)
                                       .FirstOrDefault() ?? description;
            firstLine = firstLine.Trim();
            if (firstLine.Length <= maxLength) return firstLine;
            return firstLine.Substring(0, maxLength).Trim() + "…";
        }

        // Simple service provider stub
        private class SimpleServiceProviderStub : IServiceProvider
        {
            public object? GetService(Type serviceType) => null;
        }

        // Design-time / no-op stubs to compile standalone
        private class NoOpRequirementService : IRequirementService
        {
            public List<Requirement> ImportRequirementsFromJamaAllDataDocx(string path) => new List<Requirement>();
            public List<Requirement> ImportRequirementsFromWord(string path) => new List<Requirement>();
            public string ExportAllGeneratedTestCasesToCsv(IEnumerable<Requirement> requirements, string folderPath, string filePrefix, string extra) => string.Empty;
            public void ExportAllGeneratedTestCasesToExcel(IEnumerable<Requirement> requirements, string outputPath) { /* no-op */ }
        }

        private class NoOpPersistenceService : IPersistenceService
        {
            public void Save<T>(string key, T value) { }
            public T? Load<T>(string keyOrPath) => default;
            public void Save(string path, Workspace workspace) { }
            public bool Exists(string path) => false;
        }

        private class NoOpFileDialogService : IFileDialogService
        {
            public string ShowSaveFile(string title, string suggestedFileName, string filter, string defaultExt, string initialDirectory) => string.Empty;
        }

        // Dispose/unsubscribe
        public void Dispose()
        {
            try { if (Requirements != null) Requirements.CollectionChanged -= RequirementsOnCollectionChanged; } catch { }
            try { UnhookOldRequirement(); } catch { }
            try { if (_statusTimer != null) { _status_timer_stop_safe(); _statusTimer = null; } } catch { }
            try { if (_requirementsNavigator is IDisposable d) d.Dispose(); } catch { }
            try { if (HeaderViewModel is IDisposable hd) hd.Dispose(); } catch { }
        }

        private void _status_timer_stop_safe()
        {
            try { _statusTimer?.Stop(); } catch { }
        }

        // Explicit IRequirementsNavigator mappings
        ICommand? IRequirementsNavigator.NextRequirementCommand => this.NextRequirementCommand;
        ICommand? IRequirementsNavigator.PreviousRequirementCommand => this.PreviousRequirementCommand;
        ICommand? IRequirementsNavigator.NextWithoutTestCaseCommand => this.NextWithoutTestCaseCommand;
    }
}