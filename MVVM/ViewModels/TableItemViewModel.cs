using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using EditableDataControl.ViewModels;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Windows;
using TestCaseEditorApp.Interfaces;
using TestCaseEditorApp.Services;

namespace TestCaseEditorApp.MVVM.ViewModels
{
    /// <summary>
    /// UI wrapper around Services.TableDto for binding in the Support Content panel.
    /// Implements the local ITableViewProvider used by the editor and ProviderBackplane
    /// so the EditableTableEditorWindow can operate against it.
    ///
    /// Improvements in this version:
    /// - When editor promotes a row into headers (or otherwise leaves an empty row),
    ///   ReplaceWith trims leading empty rows so you don't get a blank first row persisted.
    /// - ToDto trims leading/trailing all-empty rows before creating the DTO so persisted data
    ///   doesn't contain an accidental empty row.
    /// </summary>
    public partial class TableItemViewModel : ObservableObject, ITableViewProvider, ProviderBackplane
    {
        // Backing DTO (source snapshot; immutable Rows are not modified in-place)
        public TableDto SourceDto { get; }

        // Title exposed to editor / UI (generated by source generator)
        [ObservableProperty] private string title = string.Empty;

        // Editor contract: columns and rows (EditableDataControl types). Generated properties: Columns, Rows.
        [ObservableProperty] private ObservableCollection<ColumnDefinitionModel> columns = new();
        [ObservableProperty] private ObservableCollection<TableRowModel> rows = new();

        // UI flags
        [ObservableProperty] private bool isSelected;
        [ObservableProperty] private bool isEditing;

        // Editor ViewModel for embedded editing
        [ObservableProperty] private EditableTableEditorViewModel? editorViewModel;

        // Optional owner-supplied callback used by MainViewModel to open a shared editor
        public Action<ITableViewProvider>? EditTableCallback { get; set; }

        // Commands bound from the UI
        public IRelayCommand EditTableCommand { get; }
        public IRelayCommand SaveTableCommand { get; }
        public IRelayCommand CancelEditCommand { get; }

        public TableItemViewModel(TableDto dto, Action<ITableViewProvider>? editCallback = null)
        {
            SourceDto = dto ?? throw new ArgumentNullException(nameof(dto));
            EditTableCallback = editCallback;

            // Initialize Title
            Title = dto.Title ?? string.Empty;

            // Build columns: use DTO headers if present; ensure each column has a binding key
            var headers = dto.Columns ?? new List<string>();
            if (headers.Count == 0)
            {
                var maxCols = dto.Rows?.Count > 0 ? dto.Rows.Max(r => r?.Count ?? 0) : 0;
                if (maxCols <= 0) maxCols = 1;
                headers = Enumerable.Range(0, maxCols).Select(i => $"Column {i + 1}").ToList();
            }

            int idx = 0;
            foreach (var h in headers)
            {
                var key = string.IsNullOrWhiteSpace(h) ? $"c{idx}" : h;
                Columns.Add(new ColumnDefinitionModel
                {
                    Header = string.IsNullOrWhiteSpace(h) ? $"Column {idx + 1}" : h,
                    BindingPath = key
                });
                idx++;
            }

            // Build rows: map each DTO row (List<string>) to a TableRowModel keyed by Columns.BindingPath
            var dtoRows = dto.Rows ?? new List<List<string>>();
            foreach (var r in dtoRows)
            {
                var tr = new TableRowModel();
                for (int c = 0; c < Columns.Count; c++)
                {
                    var key = Columns[c].BindingPath ?? $"c{c}";
                    var val = (r != null && c < r.Count) ? (r[c] ?? string.Empty) : string.Empty;
                    tr[key] = val;
                }
                Rows.Add(tr);
            }

            // Ensure at least one empty row if none provided
            if (Rows.Count == 0)
            {
                var tr = new TableRowModel();
                foreach (var c in Columns) tr[c.BindingPath ?? ""] = string.Empty;
                Rows.Add(tr);
            }

            // Default selected
            IsSelected = true;

            // Commands
            EditTableCommand = new RelayCommand(OnEditTable);
            SaveTableCommand = new RelayCommand(OnSaveTable);
            CancelEditCommand = new RelayCommand(OnCancelEdit);
        }

        private void OnEditTable()
        {
            // Use embedded editing - create editor ViewModel and enter edit mode
            EditorViewModel = EditableTableEditorViewModel.From(Title, Columns, Rows);
            IsEditing = true;
        }

        private void OnSaveTable()
        {
            // Apply changes from editor ViewModel back to this ViewModel
            if (EditorViewModel != null)
            {
                // Update title
                Title = EditorViewModel.Title;
                
                // Clear and rebuild columns and rows from editor
                Columns.Clear();
                Rows.Clear();
                
                foreach (var col in EditorViewModel.Columns)
                {
                    Columns.Add(col);
                }
                
                foreach (var row in EditorViewModel.Rows)
                {
                    Rows.Add(row);
                }
                
                // Clear editor ViewModel
                EditorViewModel = null;
            }
            
            // Exit edit mode
            IsEditing = false;
        }

        private void OnCancelEdit()
        {
            // Clear editor ViewModel without applying changes
            EditorViewModel = null;
            
            // Exit edit mode
            IsEditing = false;
        }

        private void RestoreFromDto()
        {
            // Restore title
            Title = SourceDto.Title ?? string.Empty;

            // Restore columns
            var headers = SourceDto.Columns ?? new List<string>();
            if (headers.Count == 0)
            {
                var maxCols = SourceDto.Rows?.Count > 0 ? SourceDto.Rows.Max(r => r?.Count ?? 0) : 0;
                if (maxCols <= 0) maxCols = 1;
                headers = Enumerable.Range(0, maxCols).Select(i => $"Column {i + 1}").ToList();
            }

            Columns.Clear();
            for (int i = 0; i < headers.Count; i++)
            {
                Columns.Add(new ColumnDefinitionModel
                {
                    Header = headers[i],
                    BindingPath = $"c{i}"
                });
            }

            // Restore rows
            Rows.Clear();
            if (SourceDto.Rows != null)
            {
                foreach (var srcRow in SourceDto.Rows)
                {
                    var tr = new TableRowModel();
                    if (srcRow != null)
                    {
                        for (int i = 0; i < srcRow.Count && i < Columns.Count; i++)
                        {
                            var key = Columns[i].BindingPath ?? "";
                            tr[key] = srcRow[i] ?? string.Empty;
                        }
                    }
                    Rows.Add(tr);
                }
            }

            // Ensure at least one empty row if none provided
            if (Rows.Count == 0)
            {
                var tr = new TableRowModel();
                foreach (var c in Columns) tr[c.BindingPath ?? ""] = string.Empty;
                Rows.Add(tr);
            }
        }

        /// <summary>
        /// Produce a new TableDto that reflects the current VM state (safe for persistence).
        /// Trims leading/trailing rows that are entirely empty to avoid persisting accidental blank rows
        /// that appear when a user promotes a row into headers.
        /// </summary>
        public TableDto ToDto()
        {
            var hdrs = Columns.Select(c => c.Header ?? string.Empty).ToList();

            var rowLists = new List<List<string>>();
            foreach (var r in Rows)
            {
                var list = new List<string>();
                foreach (var c in Columns)
                {
                    var key = c.BindingPath ?? string.Empty;
                    string value = string.Empty;
                    try
                    {
                        value = r?[key] ?? string.Empty;
                    }
                    catch
                    {
                        var p = r?.GetType().GetProperty("Item", new[] { typeof(string) });
                        if (p != null) value = p.GetValue(r, new object[] { key })?.ToString() ?? string.Empty;
                    }
                    list.Add(value ?? string.Empty);
                }
                rowLists.Add(list);
            }

            // Trim leading and trailing all-empty rows (common when a row was promoted to header)
            int start = 0;
            while (start < rowLists.Count && rowLists[start].All(string.IsNullOrWhiteSpace)) start++;
            int end = rowLists.Count - 1;
            while (end >= start && rowLists[end].All(string.IsNullOrWhiteSpace)) end--;

            var trimmed = (start <= end) ? rowLists.Skip(start).Take(end - start + 1).ToList() : new List<List<string>>();

            TestCaseEditorApp.Services.Logging.Log.Debug($"[ToDto] Title={Title}; Cols={hdrs.Count}; Rows={trimmed.Count}; FirstRow=[{(trimmed.Count > 0 ? string.Join("|", trimmed[0]) : "<none>")}]");

            // If nothing left, keep zero rows (up to caller to interpret)
            return new TableDto
            {
                Title = Title ?? string.Empty,
                Rows = trimmed,
                Columns = hdrs
            };
            
        }

        // ProviderBackplane implementation — editor will call this on OK to write-through edits into VM
        public void ReplaceWith(ObservableCollection<ColumnDefinitionModel> newCols,
                                ObservableCollection<TableRowModel> newRows)
        {
            if (newCols == null) throw new ArgumentNullException(nameof(newCols));
            if (newRows == null) throw new ArgumentNullException(nameof(newRows));

            Columns.Clear();
            foreach (var c in newCols)
                Columns.Add(new ColumnDefinitionModel { Header = c.Header, BindingPath = c.BindingPath });

            Rows.Clear();
            foreach (var r in newRows)
            {
                var nr = new TableRowModel();
                foreach (var cell in r.Cells)
                    nr[cell.Key] = cell.Value ?? string.Empty;
                Rows.Add(nr);
            }

            // Trim leading all-empty rows that often result when a user promoted the first row into headers.
            TrimLeadingEmptyRows();

            // Ensure at least one row is present (UI expects it)
            if (Rows.Count == 0)
            {
                var tr = new TableRowModel();
                foreach (var c in Columns) tr[c.BindingPath ?? ""] = string.Empty;
                Rows.Add(tr);
            }
        }

        private void TrimLeadingEmptyRows()
        {
            // Identify leading rows where all visible columns are empty.
            while (Rows.Count > 1 && IsRowEmpty(Rows.First()))
            {
                Rows.RemoveAt(0);
            }
        }

        private bool IsRowEmpty(TableRowModel row)
        {
            foreach (var c in Columns)
            {
                var key = c.BindingPath ?? string.Empty;
                string val = string.Empty;
                try
                {
                    val = row?[key] ?? string.Empty;
                }
                catch
                {
                    var p = row?.GetType().GetProperty("Item", new[] { typeof(string) });
                    if (p != null) val = p.GetValue(row, new object[] { key })?.ToString() ?? string.Empty;
                }
                if (!string.IsNullOrWhiteSpace(val)) return false;
            }
            return true;
        }

        /// <summary>
        /// Called after the editor commits. Kept for callers that expect an AfterEditCommit method.
        /// We don't modify the original SourceDto (its Rows are init-only) — persistence is done by calling ToDto()
        /// and letting the owner VM (TestCaseGenerator_CoreVM) persist that DTO into the Requirement.
        /// </summary>
        public void AfterEditCommit()
        {
            // No-op by design. This method exists for callers that expect it (backwards compatibility).
            // If you want immediate session persistence, call SessionTableStore.Save(...) here.
        }

        public override string ToString() => Title ?? string.Empty;
    }
}