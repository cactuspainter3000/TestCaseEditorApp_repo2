using System;
using System.Windows;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using System.Windows.Input;
using TestCaseEditorApp.MVVM.Utils;
using TestCaseEditorApp.MVVM.Domains.WorkspaceManagement.Mediators;
using TestCaseEditorApp.Services;

namespace TestCaseEditorApp.MVVM.ViewModels
{
    /// <summary>
    /// ViewModel for the workspace header bar.
    /// Exposes header data and commands that MainViewModel will wire.
    /// </summary>
    public partial class WorkspaceHeaderViewModel : ObservableObject, IDisposable
    {
        // Backing reference to an optional IWindow wrapper set by the view (MainWindow)
        private IWindow? _window;

        public WorkspaceHeaderViewModel()
        {
            // Subscribe to AnythingLLM status updates via mediator
            AnythingLLMMediator.StatusUpdated += OnAnythingLLMStatusUpdated;
        }

        /// <summary>
        /// Provide the IWindow (WindowWrapper or MainWindow implementing IWindow) after construction.
        /// Call this from the view (MainWindow.Window_Loaded) so view-specific operations work.
        /// </summary>
        public void SetWindow(IWindow? window) => _window = window;

        /// <summary>
        /// Expose the window (may be null if SetWindow not called).
        /// </summary>
        public IWindow? Window => _window;

        // --- Observable properties used by the header view ---
        [ObservableProperty] private string title = "Workspace";
        [ObservableProperty] private object? badge;

        [ObservableProperty] private string? workspaceName;
        [ObservableProperty] private string? sourceInfo;

        [ObservableProperty] private string? currentRequirementTitle;
        [ObservableProperty] private string? currentRequirementSummary;
        [ObservableProperty] private string? currentRequirementId;
        [ObservableProperty] private string? currentRequirementStatus;

        [ObservableProperty] private bool hasUnsavedChanges;
        [ObservableProperty] private string? statusMessage;
        [ObservableProperty] private bool canReAnalyze;
        
        // Save status properties (proper domain location per architecture)
        [ObservableProperty] private bool canUndoLastSave;
        [ObservableProperty] private string? workspaceFilePath;
        [ObservableProperty] private bool isDirty;
        
        // AnythingLLM status properties
        [ObservableProperty] private bool isAnythingLLMAvailable;
        [ObservableProperty] private bool isAnythingLLMStarting;
        [ObservableProperty] private string anythingLLMStatusMessage = "Initializing AnythingLLM...";
        // RAG workspace status properties
        [ObservableProperty] private bool isRagInitializing = false;
        [ObservableProperty] private string ragStatusMessage = "";
        [ObservableProperty] private string? ragWorkspaceName = null;

        // Computed properties for UI visibility
        public bool CanInitializeRag => !IsRagInitializing && !string.IsNullOrEmpty(WorkspaceName);

        // --- Commands (settable so MainViewModel can wire them) ---
        // Exposed as ICommand to allow wiring from MainViewModel.
        public ICommand? ReAnalyzeCommand { get; set; }
        public ICommand? InitializeRagCommand { get; set; }
        
        // Save commands (proper domain location per architecture)
        public ICommand? SaveWorkspaceCommand { get; set; }
        public ICommand? UndoLastSaveCommand { get; set; }

        // Expose this ViewModel as DataContext for XAML binding compatibility  
        public object DataContext => this;

        // --- Window control commands generated by source-gen (CommunityToolkit) ---
        // These implement ICommand and can be bound directly in XAML (CloseCommand, MinimizeCommand, MaximizeRestoreCommand).

        [RelayCommand]
        private void Close()
        {
            try
            {
                if (_window != null)
                {
                    _window.Close();
                    return;
                }

                var appWin = Application.Current?.MainWindow;
                appWin?.Close();
            }
            catch { /* best-effort */ }
        }

        [RelayCommand]
        private void Minimize()
        {
            try
            {
                if (_window != null)
                {
                    _window.WindowState = WindowState.Minimized;
                    return;
                }

                var appWin = Application.Current?.MainWindow;
                if (appWin != null) appWin.WindowState = WindowState.Minimized;
            }
            catch { /* best-effort */ }
        }

        [RelayCommand]
        private void MaximizeRestore()
        {
            try
            {
                if (_window != null)
                {
                    _window.WindowState = _window.WindowState == WindowState.Maximized ? WindowState.Normal : WindowState.Maximized;
                    return;
                }

                var appWin = Application.Current?.MainWindow;
                if (appWin != null)
                {
                    appWin.WindowState = appWin.WindowState == WindowState.Maximized ? WindowState.Normal : WindowState.Maximized;
                }
            }
            catch { /* best-effort */ }
        }
        
        /// <summary>
        /// Handles AnythingLLM status updates from the mediator
        /// </summary>
        private void OnAnythingLLMStatusUpdated(AnythingLLMStatus status)
        {
            Application.Current?.Dispatcher.BeginInvoke(() =>
            {
                IsAnythingLLMAvailable = status.IsAvailable;
                IsAnythingLLMStarting = status.IsStarting;
                AnythingLLMStatusMessage = status.StatusMessage;
            });
        }
        
        /// <summary>
        /// Clean up event subscriptions
        /// </summary>
        public void Dispose()
        {
            AnythingLLMMediator.StatusUpdated -= OnAnythingLLMStatusUpdated;
        }
        
        /// <summary>
        /// Update save status from workspace management mediator
        /// </summary>
        public void UpdateSaveStatus(IWorkspaceManagementMediator mediator)
        {
            ArgumentNullException.ThrowIfNull(mediator);
            
            IsDirty = mediator.HasUnsavedChanges();
            CanUndoLastSave = mediator.CanUndoLastSave();
            // For now, we'll set this to null until we expose the current project path
            WorkspaceFilePath = null;
        }
    }
}